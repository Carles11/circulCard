/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/websocket";
exports.ids = ["vendor-chunks/websocket"];
exports.modules = {

/***/ "(rsc)/./node_modules/websocket/index.js":
/*!*****************************************!*\
  !*** ./node_modules/websocket/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./lib/websocket */ \"(rsc)/./node_modules/websocket/lib/websocket.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsOEdBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9pbmRleC5qcz8zMDNkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/Deprecation.js":
/*!***************************************************!*\
  !*** ./node_modules/websocket/lib/Deprecation.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar Deprecation = {\n    disableWarnings: false,\n    deprecationWarningMap: {},\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn(\"DEPRECATION WARNING: \" + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\nmodule.exports = Deprecation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLGNBQWM7SUFDZEMsaUJBQWlCO0lBRWpCQyx1QkFBdUIsQ0FFdkI7SUFFQUMsTUFBTSxTQUFTQyxlQUFlO1FBQzFCLElBQUksQ0FBQyxJQUFJLENBQUNILGVBQWUsSUFBSSxJQUFJLENBQUNDLHFCQUFxQixDQUFDRSxnQkFBZ0IsRUFBRTtZQUN0RUMsUUFBUUYsSUFBSSxDQUFDLDBCQUEwQixJQUFJLENBQUNELHFCQUFxQixDQUFDRSxnQkFBZ0I7WUFDbEYsSUFBSSxDQUFDRixxQkFBcUIsQ0FBQ0UsZ0JBQWdCLEdBQUc7UUFDbEQ7SUFDSjtBQUNKO0FBRUFFLE9BQU9DLE9BQU8sR0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcz83OWM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIERlcHJlY2F0aW9uID0ge1xuICAgIGRpc2FibGVXYXJuaW5nczogZmFsc2UsXG5cbiAgICBkZXByZWNhdGlvbldhcm5pbmdNYXA6IHtcblxuICAgIH0sXG5cbiAgICB3YXJuOiBmdW5jdGlvbihkZXByZWNhdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVXYXJuaW5ncyAmJiB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6ICcgKyB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nTWFwW2RlcHJlY2F0aW9uTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVwcmVjYXRpb247XG4iXSwibmFtZXMiOlsiRGVwcmVjYXRpb24iLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGlvbldhcm5pbmdNYXAiLCJ3YXJuIiwiZGVwcmVjYXRpb25OYW1lIiwiY29uc29sZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/Deprecation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/W3CWebSocket.js":
/*!****************************************************!*\
  !*** ./node_modules/websocket/lib/W3CWebSocket.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ \"(rsc)/./node_modules/websocket/lib/WebSocketClient.js\");\nvar toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"(rsc)/./node_modules/typedarray-to-buffer/index.js\");\nvar yaeti = __webpack_require__(/*! yaeti */ \"(rsc)/./node_modules/yaeti/index.js\");\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\nmodule.exports = W3CWebSocket;\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true; // Required in the W3C API.\n    var self = this;\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = \"\";\n    this._bufferedAmount = 0; // Hack, always 0.\n    this._binaryType = \"arraybuffer\"; // TODO: Should be 'blob' by default, but Node has no Blob.\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n    this._client.on(\"connect\", function(connection) {\n        onConnect.call(self, connection);\n    });\n    this._client.on(\"connectFailed\", function() {\n        onConnectFailed.call(self);\n    });\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url: {\n        get: function() {\n            return this._url;\n        }\n    },\n    readyState: {\n        get: function() {\n            return this._readyState;\n        }\n    },\n    protocol: {\n        get: function() {\n            return this._protocol;\n        }\n    },\n    extensions: {\n        get: function() {\n            return this._extensions;\n        }\n    },\n    bufferedAmount: {\n        get: function() {\n            return this._bufferedAmount;\n        }\n    }\n});\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== \"arraybuffer\") {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error(\"cannot call send() while not connected\");\n    }\n    // Text.\n    if (typeof data === \"string\" || data instanceof String) {\n        this._connection.sendUTF(data);\n    } else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        } else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        } else {\n            throw new Error(\"unknown binary data:\", data);\n        }\n    }\n};\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState){\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on(\"connect\", function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n/**\n * Private API.\n */ function createCloseEvent(code, reason) {\n    var event = new yaeti.Event(\"close\");\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = typeof code === \"undefined\" || code === 1000;\n    return event;\n}\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event(\"message\");\n    event.data = data;\n    return event;\n}\nfunction onConnect(connection) {\n    var self = this;\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n    this._connection.on(\"close\", function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n    this._connection.on(\"message\", function(msg) {\n        onMessage.call(self, msg);\n    });\n    this.dispatchEvent(new yaeti.Event(\"open\"));\n}\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    try {\n        this.dispatchEvent(new yaeti.Event(\"error\"));\n    } finally{\n        this.dispatchEvent(createCloseEvent(1006, \"connection failed\"));\n    }\n}\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    this.dispatchEvent(createCloseEvent(code, reason || \"\"));\n}\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    } else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === \"arraybuffer\") {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for(var i = 0, len = buffer.length; i < len; ++i){\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxrQkFBa0JDLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBR3BCLE1BQU1HLGFBQWE7QUFDbkIsTUFBTUMsT0FBTztBQUNiLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUdmQyxPQUFPQyxPQUFPLEdBQUdDO0FBR2pCLFNBQVNBLGFBQWFDLEdBQUcsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxZQUFZO0lBQy9FLDRCQUE0QjtJQUM1QmIsTUFBTWMsV0FBVyxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUUzQix5QkFBeUI7SUFDekJGLGVBQWVBLGdCQUFnQixDQUFDO0lBQ2hDQSxhQUFhRyxpQkFBaUIsR0FBRyxNQUFPLDJCQUEyQjtJQUVuRSxJQUFJQyxPQUFPLElBQUk7SUFFZixJQUFJLENBQUNDLElBQUksR0FBR1Y7SUFDWixJQUFJLENBQUNXLFdBQVcsR0FBR2xCO0lBQ25CLElBQUksQ0FBQ21CLFNBQVMsR0FBR0M7SUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDbkIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsR0FBSSxrQkFBa0I7SUFDN0MsSUFBSSxDQUFDQyxXQUFXLEdBQUcsZUFBZ0IsMkRBQTJEO0lBRTlGLG9DQUFvQztJQUNwQyxJQUFJLENBQUNDLFdBQVcsR0FBR0o7SUFFbkIsNEJBQTRCO0lBQzVCLElBQUksQ0FBQ0ssT0FBTyxHQUFHLElBQUk3QixnQkFBZ0JnQjtJQUVuQyxJQUFJLENBQUNhLE9BQU8sQ0FBQ0MsRUFBRSxDQUFDLFdBQVcsU0FBU0MsVUFBVTtRQUMxQ0MsVUFBVWQsSUFBSSxDQUFDRSxNQUFNVztJQUN6QjtJQUVB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QUFNO1lBQy9DLElBQUlDLE9BQU8sSUFBSUMsV0FBV0o7WUFDMUIsSUFBSyxJQUFJSyxJQUFFLEdBQUdDLE1BQUlQLE9BQU9HLE1BQU0sRUFBRUcsSUFBRUMsS0FBSyxFQUFFRCxFQUFHO2dCQUN6Q0YsSUFBSSxDQUFDRSxFQUFFLEdBQUdOLE1BQU0sQ0FBQ00sRUFBRTtZQUN2QjtZQUNBLElBQUksQ0FBQ1gsYUFBYSxDQUFDSixtQkFBbUJVO1FBQzFDO0lBQ0o7QUFDSjtBQUdBLFNBQVNMO0lBQ0wsSUFBSSxDQUFDekMsT0FBTyxDQUFDcUQsa0JBQWtCO0lBQy9CLElBQUksSUFBSSxDQUFDdEQsV0FBVyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsV0FBVyxDQUFDc0Qsa0JBQWtCO0lBQ3ZDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanM/MzMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBXZWJTb2NrZXRDbGllbnQgPSByZXF1aXJlKCcuL1dlYlNvY2tldENsaWVudCcpO1xudmFyIHRvQnVmZmVyID0gcmVxdWlyZSgndHlwZWRhcnJheS10by1idWZmZXInKTtcbnZhciB5YWV0aSA9IHJlcXVpcmUoJ3lhZXRpJyk7XG5cblxuY29uc3QgQ09OTkVDVElORyA9IDA7XG5jb25zdCBPUEVOID0gMTtcbmNvbnN0IENMT1NJTkcgPSAyO1xuY29uc3QgQ0xPU0VEID0gMztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFczQ1dlYlNvY2tldDtcblxuXG5mdW5jdGlvbiBXM0NXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMsIG9yaWdpbiwgaGVhZGVycywgcmVxdWVzdE9wdGlvbnMsIGNsaWVudENvbmZpZykge1xuICAgIC8vIE1ha2UgdGhpcyBhbiBFdmVudFRhcmdldC5cbiAgICB5YWV0aS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU2FuaXRpemUgY2xpZW50Q29uZmlnLlxuICAgIGNsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZyB8fCB7fTtcbiAgICBjbGllbnRDb25maWcuYXNzZW1ibGVGcmFnbWVudHMgPSB0cnVlOyAgLy8gUmVxdWlyZWQgaW4gdGhlIFczQyBBUEkuXG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9ICcnO1xuICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDsgIC8vIEhhY2ssIGFsd2F5cyAwLlxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInOyAgLy8gVE9ETzogU2hvdWxkIGJlICdibG9iJyBieSBkZWZhdWx0LCBidXQgTm9kZSBoYXMgbm8gQmxvYi5cblxuICAgIC8vIFRoZSBXZWJTb2NrZXRDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBXZWJTb2NrZXRDbGllbnQgaW5zdGFuY2UuXG4gICAgdGhpcy5fY2xpZW50ID0gbmV3IFdlYlNvY2tldENsaWVudChjbGllbnRDb25maWcpO1xuXG4gICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBvbkNvbm5lY3QuY2FsbChzZWxmLCBjb25uZWN0aW9uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaWVudC5vbignY29ubmVjdEZhaWxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkNvbm5lY3RGYWlsZWQuY2FsbChzZWxmKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaWVudC5jb25uZWN0KHVybCwgcHJvdG9jb2xzLCBvcmlnaW4sIGhlYWRlcnMsIHJlcXVlc3RPcHRpb25zKTtcbn1cblxuXG4vLyBFeHBvc2UgVzNDIHJlYWQgb25seSBhdHRyaWJ1dGVzLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICAgIHVybDogICAgICAgICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl91cmw7ICAgICAgICAgICAgfSB9LFxuICAgIHJlYWR5U3RhdGU6ICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9yZWFkeVN0YXRlOyAgICAgfSB9LFxuICAgIHByb3RvY29sOiAgICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcm90b2NvbDsgICAgICAgfSB9LFxuICAgIGV4dGVuc2lvbnM6ICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9leHRlbnNpb25zOyAgICAgfSB9LFxuICAgIGJ1ZmZlcmVkQW1vdW50OiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDsgfSB9XG59KTtcblxuXG4vLyBFeHBvc2UgVzNDIHdyaXRlL3JlYWQgYXR0cmlidXRlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFczQ1dlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgICBiaW5hcnlUeXBlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBKdXN0ICdhcnJheWJ1ZmZlcicgc3VwcG9ydGVkLlxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2p1c3QgXCJhcnJheWJ1ZmZlclwiIHR5cGUgYWxsb3dlZCBmb3IgXCJiaW5hcnlUeXBlXCIgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIEV4cG9zZSBXM0MgcmVhZHlTdGF0ZSBjb25zdGFudHMgaW50byB0aGUgV2ViU29ja2V0IGluc3RhbmNlIGFzIFczQyBzdGF0ZXMuXG5bWydDT05ORUNUSU5HJyxDT05ORUNUSU5HXSwgWydPUEVOJyxPUEVOXSwgWydDTE9TSU5HJyxDTE9TSU5HXSwgWydDTE9TRUQnLENMT1NFRF1dLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHlbMF0sIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHByb3BlcnR5WzFdOyB9XG4gICAgfSk7XG59KTtcblxuLy8gQWxzbyBleHBvc2UgVzNDIHJlYWR5U3RhdGUgY29uc3RhbnRzIGludG8gdGhlIFdlYlNvY2tldCBjbGFzcyAobm90IGRlZmluZWQgYnkgdGhlIFczQyxcbi8vIGJ1dCB0aGVyZSBhcmUgc28gbWFueSBsaWJzIHJlbHlpbmcgb24gdGhlbSkuXG5bWydDT05ORUNUSU5HJyxDT05ORUNUSU5HXSwgWydPUEVOJyxPUEVOXSwgWydDTE9TSU5HJyxDTE9TSU5HXSwgWydDTE9TRUQnLENMT1NFRF1dLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wZXJ0eVswXSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvcGVydHlbMV07IH1cbiAgICB9KTtcbn0pO1xuXG5cblczQ1dlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gT1BFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHNlbmQoKSB3aGlsZSBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gVGV4dC5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kVVRGKGRhdGEpO1xuICAgIH1cbiAgICAvLyBCaW5hcnkuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vZGUgQnVmZmVyLlxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kQnl0ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3IGNvbnZlcnQgaXQgdG8gTm9kZSBCdWZmZXIuXG4gICAgICAgIGVsc2UgaWYgKGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZEJ5dGVzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJpbmFyeSBkYXRhOicsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5XM0NXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgc3dpdGNoKHRoaXMuX3JlYWR5U3RhdGUpIHtcbiAgICAgICAgY2FzZSBDT05ORUNUSU5HOlxuICAgICAgICAgICAgLy8gTk9URTogV2UgZG9uJ3QgaGF2ZSB0aGUgV2ViU29ja2V0Q29ubmVjdGlvbiBpbnN0YW5jZSB5ZXQgc28gbm9cbiAgICAgICAgICAgIC8vIHdheSB0byBjbG9zZSB0aGUgVENQIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAvLyBBcnRpZmljaWFsbHkgaW52b2tlIHRoZSBvbkNvbm5lY3RGYWlsZWQgZXZlbnQuXG4gICAgICAgICAgICBvbkNvbm5lY3RGYWlsZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8vIEFuZCBjbG9zZSBpZiBpdCBjb25uZWN0cyBhZnRlciBhIHdoaWxlLlxuICAgICAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUEVOOlxuICAgICAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENMT1NJTkc7XG4gICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ0xPU0lORzpcbiAgICAgICAgY2FzZSBDTE9TRUQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogUHJpdmF0ZSBBUEkuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDbG9zZUV2ZW50KGNvZGUsIHJlYXNvbikge1xuICAgIHZhciBldmVudCA9IG5ldyB5YWV0aS5FdmVudCgnY2xvc2UnKTtcblxuICAgIGV2ZW50LmNvZGUgPSBjb2RlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC53YXNDbGVhbiA9ICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29kZSA9PT0gMTAwMCk7XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgeWFldGkuRXZlbnQoJ21lc3NhZ2UnKTtcblxuICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xuXG4gICAgcmV0dXJuIGV2ZW50O1xufVxuXG5cbmZ1bmN0aW9uIG9uQ29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IE9QRU47XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBjb25uZWN0aW9uLnByb3RvY29sO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBjb25uZWN0aW9uLmV4dGVuc2lvbnM7XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgICAgICBvbkNsb3NlLmNhbGwoc2VsZiwgY29kZSwgcmVhc29uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgb25NZXNzYWdlLmNhbGwoc2VsZiwgbXNnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgeWFldGkuRXZlbnQoJ29wZW4nKSk7XG59XG5cblxuZnVuY3Rpb24gb25Db25uZWN0RmFpbGVkKCkge1xuICAgIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0VEO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyB5YWV0aS5FdmVudCgnZXJyb3InKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUNsb3NlRXZlbnQoMTAwNiwgJ2Nvbm5lY3Rpb24gZmFpbGVkJykpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBvbkNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0VEO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUNsb3NlRXZlbnQoY29kZSwgcmVhc29uIHx8ICcnKSk7XG59XG5cblxuZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS51dGY4RGF0YSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlTWVzc2FnZUV2ZW50KG1lc3NhZ2UudXRmOERhdGEpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWVzc2FnZS5iaW5hcnlEYXRhKSB7XG4gICAgICAgIC8vIE11c3QgY29udmVydCBmcm9tIE5vZGUgQnVmZmVyIHRvIEFycmF5QnVmZmVyLlxuICAgICAgICAvLyBUT0RPOiBvciB0byBhIEJsb2IgKHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIE5vZGUhKS5cbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG1lc3NhZ2UuYmluYXJ5RGF0YTtcbiAgICAgICAgICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49YnVmZmVyLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlTWVzc2FnZUV2ZW50KGFycmF5YnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiV2ViU29ja2V0Q2xpZW50IiwicmVxdWlyZSIsInRvQnVmZmVyIiwieWFldGkiLCJDT05ORUNUSU5HIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJtb2R1bGUiLCJleHBvcnRzIiwiVzNDV2ViU29ja2V0IiwidXJsIiwicHJvdG9jb2xzIiwib3JpZ2luIiwiaGVhZGVycyIsInJlcXVlc3RPcHRpb25zIiwiY2xpZW50Q29uZmlnIiwiRXZlbnRUYXJnZXQiLCJjYWxsIiwiYXNzZW1ibGVGcmFnbWVudHMiLCJzZWxmIiwiX3VybCIsIl9yZWFkeVN0YXRlIiwiX3Byb3RvY29sIiwidW5kZWZpbmVkIiwiX2V4dGVuc2lvbnMiLCJfYnVmZmVyZWRBbW91bnQiLCJfYmluYXJ5VHlwZSIsIl9jb25uZWN0aW9uIiwiX2NsaWVudCIsIm9uIiwiY29ubmVjdGlvbiIsIm9uQ29ubmVjdCIsIm9uQ29ubmVjdEZhaWxlZCIsImNvbm5lY3QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiZ2V0IiwicmVhZHlTdGF0ZSIsInByb3RvY29sIiwiZXh0ZW5zaW9ucyIsImJ1ZmZlcmVkQW1vdW50IiwiYmluYXJ5VHlwZSIsInNldCIsInR5cGUiLCJTeW50YXhFcnJvciIsImZvckVhY2giLCJwcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwic2VuZCIsImRhdGEiLCJFcnJvciIsIlN0cmluZyIsInNlbmRVVEYiLCJCdWZmZXIiLCJzZW5kQnl0ZXMiLCJieXRlTGVuZ3RoIiwiY2xvc2UiLCJjb2RlIiwicmVhc29uIiwiY3JlYXRlQ2xvc2VFdmVudCIsImV2ZW50IiwiRXZlbnQiLCJ3YXNDbGVhbiIsImNyZWF0ZU1lc3NhZ2VFdmVudCIsIm9uQ2xvc2UiLCJtc2ciLCJvbk1lc3NhZ2UiLCJkaXNwYXRjaEV2ZW50IiwiZGVzdHJveSIsIm1lc3NhZ2UiLCJ1dGY4RGF0YSIsImJpbmFyeURhdGEiLCJidWZmZXIiLCJhcnJheWJ1ZmZlciIsIkFycmF5QnVmZmVyIiwibGVuZ3RoIiwidmlldyIsIlVpbnQ4QXJyYXkiLCJpIiwibGVuIiwicmVtb3ZlQWxsTGlzdGVuZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/W3CWebSocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketClient.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketClient.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\");\nvar extend = utils.extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar protocolSeparators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar excludedTlsOptions = [\n    \"hostname\",\n    \"port\",\n    \"method\",\n    \"path\",\n    \"headers\"\n];\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    // TODO: Implement extensions\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n            tlsOptions = config.tlsOptions;\n            delete config.tlsOptions;\n        } else {\n            tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n    this._req = null;\n    switch(this.config.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error(\"Requested webSocketVersion is not supported. Allowed values are 8 and 13.\");\n    }\n}\nutil.inherits(WebSocketClient, EventEmitter);\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    if (typeof protocols === \"string\") {\n        if (protocols.length > 0) {\n            protocols = [\n                protocols\n            ];\n        } else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n    if (typeof requestUrl === \"string\") {\n        this.url = url.parse(requestUrl);\n    } else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error(\"You must specify a full WebSocket URL, including protocol.\");\n    }\n    if (!this.url.host) {\n        throw new Error(\"You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.\");\n    }\n    this.secure = this.url.protocol === \"wss:\";\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for(var i = 0; i < protocol.length; i++){\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n    var defaultPorts = {\n        \"ws:\": \"80\",\n        \"wss:\": \"443\"\n    };\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n    var nonce = bufferAllocUnsafe(16);\n    for(var i = 0; i < 16; i++){\n        nonce[i] = Math.round(Math.random() * 0xFF);\n    }\n    this.base64nonce = nonce.toString(\"base64\");\n    var hostHeaderValue = this.url.hostname;\n    if (this.url.protocol === \"ws:\" && this.url.port !== \"80\" || this.url.protocol === \"wss:\" && this.url.port !== \"443\") {\n        hostHeaderValue += \":\" + this.url.port;\n    }\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty(\"headers\")) {\n        // Allow for additional headers to be provided when connecting via HTTPS\n        extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n        // Explicitly provided headers take priority over any from tlsOptions\n        extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": this.config.webSocketVersion.toString(10),\n        \"Sec-WebSocket-Key\": this.base64nonce,\n        \"Host\": reqHeaders.Host || hostHeaderValue\n    });\n    if (this.protocols.length > 0) {\n        reqHeaders[\"Sec-WebSocket-Protocol\"] = this.protocols.join(\", \");\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders[\"Origin\"] = this.origin;\n        } else if (this.config.webSocketVersion === 8) {\n            reqHeaders[\"Sec-WebSocket-Origin\"] = this.origin;\n        }\n    }\n    // TODO: Implement extensions\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    } else if (this.url.path) {\n        pathAndQuery = \"/\" + this.url.path;\n    } else {\n        pathAndQuery = \"/\";\n    }\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit(\"connectFailed\", error);\n    }\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: \"GET\",\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for(var key in tlsOptions){\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on(\"upgrade\", function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener(\"error\", handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on(\"error\", handleRequestError);\n    req.on(\"response\", function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, \"httpResponse\") > 0) {\n            self.emit(\"httpResponse\", response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        } else {\n            var headerDumpParts = [];\n            for(var headerName in response.headers){\n                headerDumpParts.push(headerName + \": \" + response.headers[headerName]);\n            }\n            self.failHandshake(\"Server responded with a non-101 status: \" + response.statusCode + \" \" + response.statusMessage + \"\\nResponse Headers Follow:\\n\" + headerDumpParts.join(\"\\n\") + \"\\n\");\n        }\n    });\n    req.end();\n};\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n    if (this.protocols.length > 0) {\n        this.protocol = headers[\"sec-websocket-protocol\"];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake(\"Server did not respond with a requested protocol.\");\n                return;\n            }\n        } else {\n            this.failHandshake(\"Expected a Sec-WebSocket-Protocol header.\");\n            return;\n        }\n    }\n    if (!(headers[\"connection\"] && headers[\"connection\"].toLocaleLowerCase() === \"upgrade\")) {\n        this.failHandshake(\"Expected a Connection: Upgrade header from the server\");\n        return;\n    }\n    if (!(headers[\"upgrade\"] && headers[\"upgrade\"].toLocaleLowerCase() === \"websocket\")) {\n        this.failHandshake(\"Expected an Upgrade: websocket header from the server\");\n        return;\n    }\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.base64nonce + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var expectedKey = sha1.digest(\"base64\");\n    if (!headers[\"sec-websocket-accept\"]) {\n        this.failHandshake(\"Expected Sec-WebSocket-Accept header from server\");\n        return;\n    }\n    if (headers[\"sec-websocket-accept\"] !== expectedKey) {\n        this.failHandshake(\"Sec-WebSocket-Accept header from server didn't match expected value of \" + expectedKey);\n        return;\n    }\n    // TODO: Support extensions\n    this.succeedHandshake();\n};\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit(\"connectFailed\", new Error(errorDescription));\n};\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n    this.emit(\"connect\", connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\nmodule.exports = WebSocketClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxTQUFTRixNQUFNRSxNQUFNO0FBQ3pCLElBQUlDLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLGVBQWVILDBEQUE4QjtBQUNqRCxJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNuQixJQUFJSyxRQUFRTCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJTSxNQUFNTixtQkFBT0EsQ0FBQztBQUNsQixJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJUSxzQkFBc0JSLG1CQUFPQSxDQUFDO0FBQ2xDLElBQUlTLG9CQUFvQlYsTUFBTVUsaUJBQWlCO0FBRS9DLElBQUlDLHFCQUFxQjtJQUNyQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLO0lBQU07SUFDckI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBS0MsT0FBT0MsWUFBWSxDQUFDO0NBQ3RDO0FBRUQsSUFBSUMscUJBQXFCO0lBQUM7SUFBVztJQUFPO0lBQVM7SUFBTztDQUFVO0FBRXRFLFNBQVNDLGdCQUFnQkMsTUFBTTtJQUMzQix5QkFBeUI7SUFDekJaLGFBQWFhLElBQUksQ0FBQyxJQUFJO0lBRXRCLDZCQUE2QjtJQUU3QixJQUFJLENBQUNELE1BQU0sR0FBRztRQUNWLHVCQUF1QjtRQUN2QkUsc0JBQXNCO1FBRXRCLDRDQUE0QztRQUM1Qyw0QkFBNEI7UUFDNUJDLHdCQUF3QjtRQUV4QiwrREFBK0Q7UUFDL0QsaUNBQWlDO1FBQ2pDQywwQkFBMEI7UUFFMUIsZ0VBQWdFO1FBQ2hFLG1CQUFtQjtRQUNuQkMsd0JBQXdCO1FBRXhCLCtEQUErRDtRQUMvRCxvRUFBb0U7UUFDcEUsMERBQTBEO1FBQzFELHdD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LGNBQWM7SUFDbkQ7SUFDQSxJQUFJLENBQUNBLGNBQWMsR0FBRztBQUMxQjtBQUVBcEUsZ0JBQWdCZSxTQUFTLENBQUMyRSxLQUFLLEdBQUc7SUFDOUIsSUFBSSxJQUFJLENBQUM5RSxJQUFJLEVBQUU7UUFDWCxJQUFJLENBQUNBLElBQUksQ0FBQzhFLEtBQUs7SUFDbkI7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1RiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENsaWVudC5qcz8zYjBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSB1dGlscy5idWZmZXJBbGxvY1Vuc2FmZTtcblxudmFyIHByb3RvY29sU2VwYXJhdG9ycyA9IFtcbiAgICAnKCcsICcpJywgJzwnLCAnPicsICdAJyxcbiAgICAnLCcsICc7JywgJzonLCAnXFxcXCcsICdcXFwiJyxcbiAgICAnLycsICdbJywgJ10nLCAnPycsICc9JyxcbiAgICAneycsICd9JywgJyAnLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpXG5dO1xuXG52YXIgZXhjbHVkZWRUbHNPcHRpb25zID0gWydob3N0bmFtZScsJ3BvcnQnLCdtZXRob2QnLCdwYXRoJywnaGVhZGVycyddO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRDbGllbnQoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGV4dGVuc2lvbnNcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyAxTWlCIG1heCBmcmFtZSBzaXplLlxuICAgICAgICBtYXhSZWNlaXZlZEZyYW1lU2l6ZTogMHgxMDAwMDAsXG5cbiAgICAgICAgLy8gOE1pQiBtYXggbWVzc2FnZSBzaXplLCBvbmx5IGFwcGxpY2FibGUgaWZcbiAgICAgICAgLy8gYXNzZW1ibGVGcmFnbWVudHMgaXMgdHJ1ZVxuICAgICAgICBtYXhSZWNlaXZlZE1lc3NhZ2VTaXplOiAweDgwMDAwMCxcblxuICAgICAgICAvLyBPdXRnb2luZyBtZXNzYWdlcyBsYXJnZXIgdGhhbiBmcmFnbWVudGF0aW9uVGhyZXNob2xkIHdpbGwgYmVcbiAgICAgICAgLy8gc3BsaXQgaW50byBtdWx0aXBsZSBmcmFnbWVudHMuXG4gICAgICAgIGZyYWdtZW50T3V0Z29pbmdNZXNzYWdlczogdHJ1ZSxcblxuICAgICAgICAvLyBPdXRnb2luZyBmcmFtZXMgYXJlIGZyYWdtZW50ZWQgaWYgdGhleSBleGNlZWQgdGhpcyB0aHJlc2hvbGQuXG4gICAgICAgIC8vIERlZmF1bHQgaXMgMTZLaUJcbiAgICAgICAgZnJhZ21lbnRhdGlvblRocmVzaG9sZDogMHg0MDAwLFxuXG4gICAgICAgIC8vIFdoaWNoIHZlcnNpb24gb2YgdGhlIHByb3RvY29sIHRvIHVzZSBmb3IgdGhpcyBzZXNzaW9uLiAgVGhpc1xuICAgICAgICAvLyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHByb3RvY29sIGlzIGZpbmFsaXplZCBieSB0aGUgSUVURlxuICAgICAgICAvLyBJdCBpcyBvbmx5IGF2YWlsYWJsZSB0byBlYXNlIHRoZSB0cmFuc2l0aW9uIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBkcmFmdCBwcm90b2NvbCB2ZXJzaW9ucy5cbiAgICAgICAgLy8gQXQgcHJlc2VudCwgaXQgb25seSBhZmZlY3RzIHRoZSBuYW1lIG9mIHRoZSBPcmlnaW4gaGVhZGVyLlxuICAgICAgICB3ZWJTb2NrZXRWZXJzaW9uOiAxMyxcblxuICAgICAgICAvLyBJZiB0cnVlLCBmcmFnbWVudGVkIG1lc3NhZ2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBhc3NlbWJsZWRcbiAgICAgICAgLy8gYW5kIHRoZSBmdWxsIG1lc3NhZ2Ugd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdtZXNzYWdlJyBldmVudC5cbiAgICAgICAgLy8gSWYgZmFsc2UsIGVhY2ggZnJhbWUgd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdmcmFtZScgZXZlbnQgYW5kXG4gICAgICAgIC8vIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGJlIHJlc3BvbnNpYmxlIGZvciBhZ2dyZWdhdGluZyBtdWx0aXBsZVxuICAgICAgICAvLyBmcmFnbWVudGVkIGZyYW1lcy4gIFNpbmdsZS1mcmFtZSBtZXNzYWdlcyB3aWxsIGVtaXQgYSAnbWVzc2FnZSdcbiAgICAgICAgLy8gZXZlbnQgaW4gYWRkaXRpb24gdG8gdGhlICdmcmFtZScgZXZlbnQuXG4gICAgICAgIC8vIE1vc3QgdXNlcnMgd2lsbCB3YW50IHRvIGxlYXZlIHRoaXMgc2V0IHRvICd0cnVlJ1xuICAgICAgICBhc3NlbWJsZUZyYWdtZW50czogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgTmFnbGUgQWxnb3JpdGhtIG1ha2VzIG1vcmUgZWZmaWNpZW50IHVzZSBvZiBuZXR3b3JrIHJlc291cmNlc1xuICAgICAgICAvLyBieSBpbnRyb2R1Y2luZyBhIHNtYWxsIGRlbGF5IGJlZm9yZSBzZW5kaW5nIHNtYWxsIHBhY2tldHMgc28gdGhhdFxuICAgICAgICAvLyBtdWx0aXBsZSBtZXNzYWdlcyBjYW4gYmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgZ29pbmcgb250byB0aGVcbiAgICAgICAgLy8gd2lyZS4gIFRoaXMgaG93ZXZlciBjb21lcyBhdCB0aGUgY29zdCBvZiBsYXRlbmN5LCBzbyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBpcyB0byBkaXNhYmxlIGl0LiAgSWYgeW91IGRvbid0IG5lZWQgbG93IGxhdGVuY3kgYW5kIGFyZSBzdHJlYW1pbmdcbiAgICAgICAgLy8gbG90cyBvZiBzbWFsbCBtZXNzYWdlcywgeW91IGNhbiBjaGFuZ2UgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIGRpc2FibGVOYWdsZUFsZ29yaXRobTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBjbG9zZSBmcmFtZVxuICAgICAgICAvLyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IHRvIGNvbWUgYmFjayBiZWZvcmUgZ2l2aW5nIHVwIGFuZCBqdXN0XG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIHNvY2tldC5cbiAgICAgICAgY2xvc2VUaW1lb3V0OiA1MDAwLFxuXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gcGFzcyB0byBodHRwcy5jb25uZWN0IGlmIGNvbm5lY3RpbmcgdmlhIFRMU1xuICAgICAgICB0bHNPcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIHZhciB0bHNPcHRpb25zO1xuICAgICAgICBpZiAoY29uZmlnLnRsc09wdGlvbnMpIHtcbiAgICAgICAgICB0bHNPcHRpb25zID0gY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgICAgZGVsZXRlIGNvbmZpZy50bHNPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRsc09wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQodGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGV4dGVuZCh0aGlzLmNvbmZpZy50bHNPcHRpb25zLCB0bHNPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsO1xuICAgIFxuICAgIHN3aXRjaCAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbikge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHdlYlNvY2tldFZlcnNpb24gaXMgbm90IHN1cHBvcnRlZC4gQWxsb3dlZCB2YWx1ZXMgYXJlIDggYW5kIDEzLicpO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRDbGllbnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKHJlcXVlc3RVcmwsIHByb3RvY29scywgb3JpZ2luLCBoZWFkZXJzLCBleHRyYVJlcXVlc3RPcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2YocHJvdG9jb2xzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghKHByb3RvY29scyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5wcm90b2NvbHMgPSBwcm90b2NvbHM7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG5cbiAgICBpZiAodHlwZW9mKHJlcXVlc3RVcmwpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnVybCA9IHVybC5wYXJzZShyZXF1ZXN0VXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMudXJsID0gcmVxdWVzdFVybDsgLy8gaW4gY2FzZSBhbiBhbHJlYWR5IHBhcnNlZCB1cmwgaXMgcGFzc2VkIGluLlxuICAgIH1cbiAgICBpZiAoIXRoaXMudXJsLnByb3RvY29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGZ1bGwgV2ViU29ja2V0IFVSTCwgaW5jbHVkaW5nIHByb3RvY29sLicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudXJsLmhvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgZnVsbCBXZWJTb2NrZXQgVVJMLCBpbmNsdWRpbmcgaG9zdG5hbWUuIFJlbGF0aXZlIFVSTHMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWN1cmUgPSAodGhpcy51cmwucHJvdG9jb2wgPT09ICd3c3M6Jyk7XG5cbiAgICAvLyB2YWxpZGF0ZSBwcm90b2NvbCBjaGFyYWN0ZXJzOlxuICAgIHRoaXMucHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG9jb2wpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcHJvdG9jb2wubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwcm90b2NvbC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHByb3RvY29sLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4MDAyMSB8fCBjaGFyQ29kZSA+IDB4MDA3RSB8fCBwcm90b2NvbFNlcGFyYXRvcnMuaW5kZXhPZihjaGFyYWN0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgbGlzdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlciBcIicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSArICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZGVmYXVsdFBvcnRzID0ge1xuICAgICAgICAnd3M6JzogJzgwJyxcbiAgICAgICAgJ3dzczonOiAnNDQzJ1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMudXJsLnBvcnQpIHtcbiAgICAgICAgdGhpcy51cmwucG9ydCA9IGRlZmF1bHRQb3J0c1t0aGlzLnVybC5wcm90b2NvbF07XG4gICAgfVxuXG4gICAgdmFyIG5vbmNlID0gYnVmZmVyQWxsb2NVbnNhZmUoMTYpO1xuICAgIGZvciAodmFyIGk9MDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgbm9uY2VbaV0gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqMHhGRik7XG4gICAgfVxuICAgIHRoaXMuYmFzZTY0bm9uY2UgPSBub25jZS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgICB2YXIgaG9zdEhlYWRlclZhbHVlID0gdGhpcy51cmwuaG9zdG5hbWU7XG4gICAgaWYgKCh0aGlzLnVybC5wcm90b2NvbCA9PT0gJ3dzOicgJiYgdGhpcy51cmwucG9ydCAhPT0gJzgwJykgfHxcbiAgICAgICAgKHRoaXMudXJsLnByb3RvY29sID09PSAnd3NzOicgJiYgdGhpcy51cmwucG9ydCAhPT0gJzQ0MycpKSAge1xuICAgICAgICBob3N0SGVhZGVyVmFsdWUgKz0gKCc6JyArIHRoaXMudXJsLnBvcnQpO1xuICAgIH1cblxuICAgIHZhciByZXFIZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuc2VjdXJlICYmIHRoaXMuY29uZmlnLnRsc09wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2hlYWRlcnMnKSkge1xuICAgICAgLy8gQWxsb3cgZm9yIGFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBwcm92aWRlZCB3aGVuIGNvbm5lY3RpbmcgdmlhIEhUVFBTXG4gICAgICBleHRlbmQocmVxSGVhZGVycywgdGhpcy5jb25maWcudGxzT3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgcHJvdmlkZWQgaGVhZGVycyB0YWtlIHByaW9yaXR5IG92ZXIgYW55IGZyb20gdGxzT3B0aW9uc1xuICAgICAgZXh0ZW5kKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBleHRlbmQocmVxSGVhZGVycywge1xuICAgICAgICAnVXBncmFkZSc6ICd3ZWJzb2NrZXQnLFxuICAgICAgICAnQ29ubmVjdGlvbic6ICdVcGdyYWRlJyxcbiAgICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb24udG9TdHJpbmcoMTApLFxuICAgICAgICAnU2VjLVdlYlNvY2tldC1LZXknOiB0aGlzLmJhc2U2NG5vbmNlLFxuICAgICAgICAnSG9zdCc6IHJlcUhlYWRlcnMuSG9zdCB8fCBob3N0SGVhZGVyVmFsdWVcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcUhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHRoaXMucHJvdG9jb2xzLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICBpZiAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJlcUhlYWRlcnNbJ09yaWdpbiddID0gdGhpcy5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbiA9PT0gOCkge1xuICAgICAgICAgICAgcmVxSGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IHRoaXMub3JpZ2luO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGV4dGVuc2lvbnNcblxuICAgIHZhciBwYXRoQW5kUXVlcnk7XG4gICAgLy8gRW5zdXJlIGl0IGJlZ2lucyB3aXRoICcvJy5cbiAgICBpZiAodGhpcy51cmwucGF0aG5hbWUpIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gdGhpcy51cmwucGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy51cmwucGF0aCkge1xuICAgICAgICBwYXRoQW5kUXVlcnkgPSAnLycgKyB0aGlzLnVybC5wYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gJy8nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RFcnJvcihlcnJvcikge1xuICAgICAgICBzZWxmLl9yZXEgPSBudWxsO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nvbm5lY3RGYWlsZWQnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBhZ2VudDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChleHRyYVJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChyZXF1ZXN0T3B0aW9ucywgZXh0cmFSZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRoZXNlIG9wdGlvbnMgYXJlIGFsd2F5cyBvdmVycmlkZGVuIGJ5IHRoZSBsaWJyYXJ5LiAgVGhlIHVzZXIgaXMgbm90XG4gICAgLy8gYWxsb3dlZCB0byBzcGVjaWZ5IHRoZXNlIGRpcmVjdGx5LlxuICAgIGV4dGVuZChyZXF1ZXN0T3B0aW9ucywge1xuICAgICAgICBob3N0bmFtZTogdGhpcy51cmwuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHRoaXMudXJsLnBvcnQsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHBhdGg6IHBhdGhBbmRRdWVyeSxcbiAgICAgICAgaGVhZGVyczogcmVxSGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnNlY3VyZSkge1xuICAgICAgICB2YXIgdGxzT3B0aW9ucyA9IHRoaXMuY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0bHNPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGxzT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV4Y2x1ZGVkVGxzT3B0aW9ucy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnNba2V5XSA9IHRsc09wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXEgPSB0aGlzLl9yZXEgPSAodGhpcy5zZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgIHJlcS5vbigndXBncmFkZScsIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RVcGdyYWRlKHJlc3BvbnNlLCBzb2NrZXQsIGhlYWQpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVJlcXVlc3RFcnJvcik7XG4gICAgICAgIHNlbGYuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICBzZWxmLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHNlbGYuZmlyc3REYXRhQ2h1bmsgPSBoZWFkO1xuICAgICAgICBzZWxmLnZhbGlkYXRlSGFuZHNoYWtlKCk7XG4gICAgfSk7XG4gICAgcmVxLm9uKCdlcnJvcicsIGhhbmRsZVJlcXVlc3RFcnJvcik7XG5cbiAgICByZXEub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgaWYgKHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQoc2VsZiwgJ2h0dHBSZXNwb25zZScpID4gMCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdodHRwUmVzcG9uc2UnLCByZXNwb25zZSwgc2VsZik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhlYWRlckR1bXBQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyRHVtcFBhcnRzLnB1c2goaGVhZGVyTmFtZSArICc6ICcgKyByZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmFpbEhhbmRzaGFrZShcbiAgICAgICAgICAgICAgICAnU2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgbm9uLTEwMSBzdGF0dXM6ICcgK1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyAnICcgKyByZXNwb25zZS5zdGF0dXNNZXNzYWdlICtcbiAgICAgICAgICAgICAgICAnXFxuUmVzcG9uc2UgSGVhZGVycyBGb2xsb3c6XFxuJyArXG4gICAgICAgICAgICAgICAgaGVhZGVyRHVtcFBhcnRzLmpvaW4oJ1xcbicpICsgJ1xcbidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXEuZW5kKCk7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLnZhbGlkYXRlSGFuZHNoYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5wcm90b2NvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG9jb2xzLmluZGV4T2YodGhpcy5wcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggYSByZXF1ZXN0ZWQgcHJvdG9jb2wuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdFeHBlY3RlZCBhIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoaGVhZGVyc1snY29ubmVjdGlvbiddICYmIGhlYWRlcnNbJ2Nvbm5lY3Rpb24nXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSAndXBncmFkZScpKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYSBDb25uZWN0aW9uOiBVcGdyYWRlIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGhlYWRlcnNbJ3VwZ3JhZGUnXSAmJiBoZWFkZXJzWyd1cGdyYWRlJ10udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gJ3dlYnNvY2tldCcpKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYW4gVXBncmFkZTogd2Vic29ja2V0IGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBzaGExLnVwZGF0ZSh0aGlzLmJhc2U2NG5vbmNlICsgJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScpO1xuICAgIHZhciBleHBlY3RlZEtleSA9IHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmICghaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSkge1xuICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ0V4cGVjdGVkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlciBmcm9tIHNlcnZlcicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGV4cGVjdGVkS2V5KSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyIGZyb20gc2VydmVyIGRpZG5cXCd0IG1hdGNoIGV4cGVjdGVkIHZhbHVlIG9mICcgKyBleHBlY3RlZEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IGV4dGVuc2lvbnNcblxuICAgIHRoaXMuc3VjY2VlZEhhbmRzaGFrZSgpO1xufTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5mYWlsSGFuZHNoYWtlID0gZnVuY3Rpb24oZXJyb3JEZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC53cml0YWJsZSkge1xuICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0RmFpbGVkJywgbmV3IEVycm9yKGVycm9yRGVzY3JpcHRpb24pKTtcbn07XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuc3VjY2VlZEhhbmRzaGFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldENvbm5lY3Rpb24odGhpcy5zb2NrZXQsIFtdLCB0aGlzLnByb3RvY29sLCB0cnVlLCB0aGlzLmNvbmZpZyk7XG5cbiAgICBjb25uZWN0aW9uLndlYlNvY2tldFZlcnNpb24gPSB0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uO1xuICAgIGNvbm5lY3Rpb24uX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgICBpZiAodGhpcy5maXJzdERhdGFDaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uaGFuZGxlU29ja2V0RGF0YSh0aGlzLmZpcnN0RGF0YUNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5maXJzdERhdGFDaHVuayA9IG51bGw7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3JlcSkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldENsaWVudDtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJleHRlbmQiLCJ1dGlsIiwiRXZlbnRFbWl0dGVyIiwiaHR0cCIsImh0dHBzIiwidXJsIiwiY3J5cHRvIiwiV2ViU29ja2V0Q29ubmVjdGlvbiIsImJ1ZmZlckFsbG9jVW5zYWZlIiwicHJvdG9jb2xTZXBhcmF0b3JzIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhjbHVkZWRUbHNPcHRpb25zIiwiV2ViU29ja2V0Q2xpZW50IiwiY29uZmlnIiwiY2FsbCIsIm1heFJlY2VpdmVkRnJhbWVTaXplIiwibWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSIsImZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyIsImZyYWdtZW50YXRpb25UaHJlc2hvbGQiLCJ3ZWJTb2NrZXRWZXJzaW9uIiwiYXNzZW1ibGVGcmFnbWVudHMiLCJkaXNhYmxlTmFnbGVBbGdvcml0aG0iLCJjbG9zZVRpbWVvdXQiLCJ0bHNPcHRpb25zIiwiX3JlcSIsIkVycm9yIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJjb25uZWN0IiwicmVxdWVzdFVybCIsInByb3RvY29scyIsIm9yaWdpbiIsImhlYWRlcnMiLCJleHRyYVJlcXVlc3RPcHRpb25zIiwic2VsZiIsImxlbmd0aCIsIkFycmF5IiwicGFyc2UiLCJwcm90b2NvbCIsImhvc3QiLCJzZWN1cmUiLCJmb3JFYWNoIiwiaSIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImNoYXJhY3RlciIsImNoYXJBdCIsImluZGV4T2YiLCJkZWZhdWx0UG9ydHMiLCJwb3J0Iiwibm9uY2UiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCJiYXNlNjRub25jZSIsInRvU3RyaW5nIiwiaG9zdEhlYWRlclZhbHVlIiwiaG9zdG5hbWUiLCJyZXFIZWFkZXJzIiwiaGFzT3duUHJvcGVydHkiLCJIb3N0Iiwiam9pbiIsInBhdGhBbmRRdWVyeSIsInBhdGhuYW1lIiwicGF0aCIsImhhbmRsZVJlcXVlc3RFcnJvciIsImVycm9yIiwiZW1pdCIsInJlcXVlc3RPcHRpb25zIiwiYWdlbnQiLCJtZXRob2QiLCJrZXkiLCJyZXEiLCJyZXF1ZXN0Iiwib24iLCJoYW5kbGVSZXF1ZXN0VXBncmFkZSIsInJlc3BvbnNlIiwic29ja2V0IiwiaGVhZCIsInJlbW92ZUxpc3RlbmVyIiwiZmlyc3REYXRhQ2h1bmsiLCJ2YWxpZGF0ZUhhbmRzaGFrZSIsImV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQiLCJlbmQiLCJoZWFkZXJEdW1wUGFydHMiLCJoZWFkZXJOYW1lIiwicHVzaCIsImZhaWxIYW5kc2hha2UiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwic2hhMSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJleHBlY3RlZEtleSIsImRpZ2VzdCIsInN1Y2NlZWRIYW5kc2hha2UiLCJlcnJvckRlc2NyaXB0aW9uIiwid3JpdGFibGUiLCJjb25uZWN0aW9uIiwiX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzIiwiaGFuZGxlU29ja2V0RGF0YSIsImFib3J0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketConnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketConnection.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ \"(rsc)/./node_modules/websocket/lib/WebSocketFrame.js\");\nvar BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ \"(rsc)/./node_modules/websocket/vendor/FastBufferList.js\");\nvar isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(rsc)/./node_modules/utf-8-validate/index.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = \"open\";\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = \"peer_requested_close\";\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = \"ending\";\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = \"closed\";\nvar setImmediateImpl = \"setImmediate\" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);\nvar idCounter = 0;\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger(\"websocket:connection\", ++idCounter);\n    this._debug(\"constructor\");\n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._pingListenerCount = 0;\n    this.on(\"newListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount++;\n        }\n    }).on(\"removeListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount--;\n        }\n    });\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof this.config.keepaliveInterval !== \"number\") {\n            throw new Error(\"keepaliveInterval must be specified and numeric \" + \"if keepalive is true.\");\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof this.config.keepaliveGracePeriod !== \"number\") {\n                throw new Error(\"keepaliveGracePeriod  must be specified and \" + \"numeric if dropConnectionOnKeepaliveTimeout \" + \"is true.\");\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    } else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!(\"setKeepAlive\" in this.socket)) {\n            throw new Error(\"Unable to use native keepalive: unsupported by \" + \"this version of Node.\");\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners(\"error\");\n}\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: \"Normal connection closure\",\n    1001: \"Remote peer is going away\",\n    1002: \"Protocol error\",\n    1003: \"Unprocessable input\",\n    1004: \"Reserved\",\n    1005: \"Reason not provided\",\n    1006: \"Abnormal closure, no further detail available\",\n    1007: \"Invalid data received\",\n    1008: \"Policy violation\",\n    1009: \"Message too big\",\n    1010: \"Extension requested by client is required\",\n    1011: \"Internal Server Error\",\n    1015: \"TLS Handshake Failed\"\n};\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [\n            1000,\n            1001,\n            1002,\n            1003,\n            1007,\n            1008,\n            1009,\n            1010,\n            1011,\n            1012,\n            1013,\n            1014,\n            1015\n        ].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\nutil.inherits(WebSocketConnection, EventEmitter);\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on(\"error\", this.handleSocketError.bind(this));\n    this.socket.on(\"end\", this.handleSocketEnd.bind(this));\n    this.socket.on(\"close\", this.handleSocketClose.bind(this));\n    this.socket.on(\"drain\", this.handleSocketDrain.bind(this));\n    this.socket.on(\"pause\", this.handleSocketPause.bind(this));\n    this.socket.on(\"resume\", this.handleSocketResume.bind(this));\n    this.socket.on(\"data\", this.handleSocketData.bind(this));\n};\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug(\"setKeepaliveTimer\");\n    if (!this.config.keepalive || this.config.useNativeKeepalive) {\n        return;\n    }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug(\"handleKeepaliveTimer\");\n    this._keepaliveTimeoutID = null;\n    this.ping();\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    } else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug(\"setGracePeriodTimer\");\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug(\"handleGracePeriodTimer\");\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, \"Peer not responding.\", true);\n};\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug(\"handleSocketData\");\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug(\"processReceivedData\");\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) {\n        return;\n    }\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) {\n        return;\n    }\n    var frame = this.currentFrame;\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) {\n        this._debug(\"-- insufficient data for frame\");\n        return;\n    }\n    var self = this;\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug(\"-- protocol error\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    } else if (frame.frameTooLarge) {\n        this._debug(\"-- frame too large\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug(\"-- illegal rsv flag\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unsupported usage of rsv bits without negotiated extension.\");\n        });\n        return;\n    }\n    if (!this.assembleFragments) {\n        this._debug(\"-- emitting frame\");\n        process.nextTick(function() {\n            self.emit(\"frame\", frame);\n        });\n    }\n    process.nextTick(function() {\n        self.processFrame(frame);\n    });\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug(\"handleSocketError: %j\", error);\n    if (this.state === STATE_CLOSED) {\n        // See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug(\"  --- Socket 'error' after 'close'\");\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = \"Socket Error: \" + error.syscall + \" \" + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, \"error\") > 0) {\n        this.emit(\"error\", error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug(\"handleSocketEnd: received socket end.  state = %s\", this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug(\"  --- Socket 'end' after 'close'\");\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {\n        this._debug(\"  --- UNEXPECTED socket end.\");\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug(\"handleSocketClose: received socket close\");\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = \"Connection dropped by remote peer.\";\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"-- Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n};\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug(\"handleSocketDrain: socket drain event\");\n    this.outputBufferFull = false;\n    this.emit(\"drain\");\n};\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug(\"handleSocketPause: socket pause event\");\n    this.inputPaused = true;\n    this.emit(\"pause\");\n};\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug(\"handleSocketResume: socket resume event\");\n    this.inputPaused = false;\n    this.emit(\"resume\");\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.pause = function() {\n    this._debug(\"pause: pause requested\");\n    this.socket.pause();\n};\nWebSocketConnection.prototype.resume = function() {\n    this._debug(\"resume: resume requested\");\n    this.socket.resume();\n};\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug(\"close: Initating clean WebSocket close sequence.\");\n        if (\"number\" !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error(\"Close code \" + reasonCode + \" is not valid.\");\n        }\n        if (\"string\" !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug(\"drop\");\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n    if (typeof description !== \"string\") {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n    this._debug(\"Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s\", skipCloseFrame, reasonCode, description);\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n    this._debug(\"Drop: destroying socket\");\n    this.socket.destroy();\n};\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug(\"setCloseTimer\");\n    this.clearCloseTimer();\n    this._debug(\"Setting close timer\");\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug(\"clearCloseTimer\");\n    if (this.closeTimer) {\n        this._debug(\"Clearing close timer\");\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug(\"handleCloseTimer\");\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug(\"Close response not received from client.  Forcing socket end.\");\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug(\"processFrame\");\n    this._debug(\" -- frame: %s\", frame);\n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && frame.opcode > 0x00 && frame.opcode < 0x08) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Illegal frame opcode 0x\" + frame.opcode.toString(16) + \" \" + \"received in middle of fragmented message.\");\n        return;\n    }\n    switch(frame.opcode){\n        case 0x02:\n            this._debug(\"-- Binary Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"binary\",\n                        binaryData: frame.binaryPayload\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01:\n            this._debug(\"-- Text Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"utf8\",\n                        utf8Data: frame.binaryPayload.toString(\"utf8\")\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00:\n            this._debug(\"-- Continuation Frame\");\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected Continuation Frame\");\n                    return;\n                }\n                this.fragmentationSize += frame.length;\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, \"Maximum message size exceeded.\");\n                    return;\n                }\n                this.frameQueue.push(frame);\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function(currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n                    switch(opcode){\n                        case 0x02:\n                            this.emit(\"message\", {\n                                type: \"binary\",\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01:\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                                return;\n                            }\n                            this.emit(\"message\", {\n                                type: \"utf8\",\n                                utf8Data: binaryPayload.toString(\"utf8\")\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected first opcode in fragmentation sequence: 0x\" + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09:\n            this._debug(\"-- Ping Frame\");\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.emit(\"ping\", cancel, frame.binaryPayload);\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            } else {\n                this.pong(frame.binaryPayload);\n            }\n            break;\n        case 0x0A:\n            this._debug(\"-- Pong Frame\");\n            this.emit(\"pong\", frame.binaryPayload);\n            break;\n        case 0x08:\n            this._debug(\"-- Close Frame\");\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug(\"---- Got close response from peer.  Completing closing handshake.\");\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            this._debug(\"---- Closing handshake initiated by peer.\");\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            } else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString(\"utf8\");\n            } else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\"------ Remote peer %s - code: %d - %s - close frame payload length: %d\", this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);\n            this._debug(\"------ responding to remote peer's close request.\");\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug(\"-- Unrecognized Opcode %d\", frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unrecognized Opcode: 0x\" + frame.opcode.toString(16));\n            break;\n    }\n};\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug(\"send\");\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    } else if (typeof data[\"toString\"] === \"function\") {\n        this.sendUTF(data, cb);\n    } else {\n        throw new Error(\"Data provided must either be a Node Buffer or implement toString()\");\n    }\n};\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), \"utf8\");\n    this._debug(\"sendUTF: %d bytes\", data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug(\"sendBytes\");\n    if (!Buffer.isBuffer(data)) {\n        throw new Error(\"You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()\");\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug(\"ping\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), \"utf8\");\n        }\n        if (data.length > 125) {\n            this._debug(\"WebSocket: Data for ping is longer than 125 bytes.  Truncating.\");\n            data = data.slice(0, 124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug(\"pong\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug(\"WebSocket: Data for pong is longer than 125 bytes.  Truncating.\");\n        binaryPayload = binaryPayload.slice(0, 124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug(\"fragmentAndSend\");\n    if (frame.opcode > 0x07) {\n        throw new Error(\"You cannot fragment control frames.\");\n    }\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === \"function\") {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if (sentFragments === numFragments && typeof cb === \"function\") {\n            cb();\n        }\n    };\n    for(var i = 1; i <= numFragments; i++){\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        // continuation opcode except for first frame.\n        currentFrame.opcode = i === 1 ? frame.opcode : 0x00;\n        // fin set on last frame only\n        currentFrame.fin = i === numFragments;\n        // length is likely to be shorter on the last fragment\n        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;\n        var sliceStart = threshold * (i - 1);\n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    this._debug(\"sendCloseFrame state: %s, reasonCode: %d, description: %s\", this.state, reasonCode, description);\n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {\n        return;\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof description === \"string\") {\n        frame.binaryPayload = bufferFromString(description, \"utf8\");\n    }\n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug(\"sendFrame\");\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\nmodule.exports = WebSocketConnection;\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */ if (!connection._debug.enabled) {\n        return;\n    }\n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug(\"||| Socket Event  '%s'\", event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    for(var key in socket){\n        if (\"function\" !== typeof socket[key]) {\n            continue;\n        }\n        if ([\n            \"emit\"\n        ].indexOf(key) !== -1) {\n            continue;\n        }\n        (function(key) {\n            var original = socket[key];\n            if (key === \"on\") {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug(\"||| Socket method called:  %s (%s)\", key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug(\"||| Socket method called:  %s\", key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsZUFBZUYsMERBQThCO0FBQ2pELElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUksYUFBYUosbUJBQU9BLENBQUM7QUFDekIsSUFBSUssY0FBY0wsbUJBQU9BLENBQUM7QUFDMUIsSUFBSU0sb0JBQW9CTCxNQUFNSyxpQkFBaUI7QUFDL0MsSUFBSUMsbUJBQW1CTixNQUFNTSxnQkFBZ0I7QUFFN0MsMERBQTBEO0FBQzFELE1BQU1DLGFBQWE7QUFDbkIsOENBQThDO0FBQzlDLE1BQU1DLDZCQUE2QjtBQUNuQyxpRUFBaUU7QUFDakUsTUFBTUMsZUFBZTtBQUNyQix3RUFBd0U7QUFDeEUsTUFBTUMsZUFBZTtBQUVyQixJQUFJQyxtQkFBbUIsa0JBQW1CQyxTQUNkQSxPQUFPQyxZQUFZLENBQUNDLElBQUksQ0FBQ0YsVUFDekJHLFFBQVFDLFFBQVEsQ0FBQ0YsSUFBSSxDQUFDQztBQUVsRCxJQUFJRSxZQUFZO0FBRWhCLFNBQVNDLG9CQUFvQkMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsbUJBQW1CLEVBQUVDLE1BQU07SUFDbEYsSUFBSSxDQUFDQyxNQUFNLEdBQUd4QixNQUFNeUIsZUFBZSxDQUFDLHdCQUF3QixFQUFFUjtJQUM5RCxJQUFJLENBQUNPLE1BQU0sQ0FBQztJQUVaLElBQUksSUFBSSxDQUFDQSxNQUFNLENBQUNFLE9BQU8sRUFBRTtRQUNyQkMsNkJBQTZCLElBQUksRUFBRVI7SUFDdkM7SUFFQSx5QkFBeUI7SUFDekJsQixhQUFhMkIsSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztJQUMx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LE9BQU9FLFNBQVNILEtBQUssQ0FBQyxJQUFJLEVBQUVDO2dCQUNoQztnQkFDQTtZQUNKO1lBQ0F2SyxNQUFNLENBQUN3SyxJQUFJLEdBQUcsU0FBU0c7Z0JBQ25CUixXQUFXOUosTUFBTSxDQUFDLGlDQUFpQ21LO2dCQUNuRCxPQUFPQyxTQUFTSCxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUNoQztRQUNKLEdBQUdDO0lBQ1A7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENvbm5lY3Rpb24uanM/NGU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRGcmFtZSA9IHJlcXVpcmUoJy4vV2ViU29ja2V0RnJhbWUnKTtcbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi4vdmVuZG9yL0Zhc3RCdWZmZXJMaXN0Jyk7XG52YXIgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xudmFyIGJ1ZmZlckFsbG9jVW5zYWZlID0gdXRpbHMuYnVmZmVyQWxsb2NVbnNhZmU7XG52YXIgYnVmZmVyRnJvbVN0cmluZyA9IHV0aWxzLmJ1ZmZlckZyb21TdHJpbmc7XG5cbi8vIENvbm5lY3RlZCwgZnVsbHktb3BlbiwgcmVhZHkgdG8gc2VuZCBhbmQgcmVjZWl2ZSBmcmFtZXNcbmNvbnN0IFNUQVRFX09QRU4gPSAnb3Blbic7XG4vLyBSZWNlaXZlZCBhIGNsb3NlIGZyYW1lIGZyb20gdGhlIHJlbW90ZSBwZWVyXG5jb25zdCBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRSA9ICdwZWVyX3JlcXVlc3RlZF9jbG9zZSc7XG4vLyBTZW50IGNsb3NlIGZyYW1lIHRvIHJlbW90ZSBwZWVyLiAgTm8gZnVydGhlciBkYXRhIGNhbiBiZSBzZW50LlxuY29uc3QgU1RBVEVfRU5ESU5HID0gJ2VuZGluZyc7XG4vLyBDb25uZWN0aW9uIGlzIGZ1bGx5IGNsb3NlZC4gIE5vIGZ1cnRoZXIgZGF0YSBjYW4gYmUgc2VudCBvciByZWNlaXZlZC5cbmNvbnN0IFNUQVRFX0NMT1NFRCA9ICdjbG9zZWQnO1xuXG52YXIgc2V0SW1tZWRpYXRlSW1wbCA9ICgnc2V0SW1tZWRpYXRlJyBpbiBnbG9iYWwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwuc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFsKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljay5iaW5kKHByb2Nlc3MpO1xuXG52YXIgaWRDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gV2ViU29ja2V0Q29ubmVjdGlvbihzb2NrZXQsIGV4dGVuc2lvbnMsIHByb3RvY29sLCBtYXNrT3V0Z29pbmdQYWNrZXRzLCBjb25maWcpIHtcbiAgICB0aGlzLl9kZWJ1ZyA9IHV0aWxzLkJ1ZmZlcmluZ0xvZ2dlcignd2Vic29ja2V0OmNvbm5lY3Rpb24nLCArK2lkQ291bnRlcik7XG4gICAgdGhpcy5fZGVidWcoJ2NvbnN0cnVjdG9yJyk7XG4gICAgXG4gICAgaWYgKHRoaXMuX2RlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgaW5zdHJ1bWVudFNvY2tldEZvckRlYnVnZ2luZyh0aGlzLCBzb2NrZXQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9waW5nTGlzdGVuZXJDb3VudCA9IDA7XG4gICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYgPT09ICdwaW5nJyl7XG4gICAgICAgICAgICB0aGlzLl9waW5nTGlzdGVuZXJDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9KS5vbigncmVtb3ZlTGlzdGVuZXInLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYgPT09ICdwaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fcGluZ0xpc3RlbmVyQ291bnQtLTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSAtMTtcbiAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBudWxsO1xuICAgIHRoaXMuY2xvc2VFdmVudEVtaXR0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFdlIGhhdmUgdG8gbWFzayBvdXRnb2luZyBwYWNrZXRzIGlmIHdlJ3JlIGFjdGluZyBhcyBhIFdlYlNvY2tldCBjbGllbnQuXG4gICAgdGhpcy5tYXNrT3V0Z29pbmdQYWNrZXRzID0gbWFza091dGdvaW5nUGFja2V0cztcblxuICAgIC8vIFdlIHJlLXVzZSB0aGUgc2FtZSBidWZmZXJzIGZvciB0aGUgbWFzayBhbmQgZnJhbWUgaGVhZGVyIGZvciBhbGwgZnJhbWVzXG4gICAgLy8gcmVjZWl2ZWQgb24gZWFjaCBjb25uZWN0aW9uIHRvIGF2b2lkIGEgc21hbGwgbWVtb3J5IGFsbG9jYXRpb24gZm9yIGVhY2hcbiAgICAvLyBmcmFtZS5cbiAgICB0aGlzLm1hc2tCeXRlcyA9IGJ1ZmZlckFsbG9jVW5zYWZlKDQpO1xuICAgIHRoaXMuZnJhbWVIZWFkZXIgPSBidWZmZXJBbGxvY1Vuc2FmZSgxMCk7XG5cbiAgICAvLyB0aGUgQnVmZmVyTGlzdCB3aWxsIGhhbmRsZSB0aGUgZGF0YSBzdHJlYW1pbmcgaW5cbiAgICB0aGlzLmJ1ZmZlckxpc3QgPSBuZXcgQnVmZmVyTGlzdCgpO1xuXG4gICAgLy8gUHJlcGFyZSBmb3IgcmVjZWl2aW5nIGZpcnN0IGZyYW1lXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDsgLy8gZGF0YSByZWNlaXZlZCBzbyBmYXIuLi5cbiAgICB0aGlzLmZyYW1lUXVldWUgPSBbXTtcbiAgICBcbiAgICAvLyBWYXJpb3VzIGJpdHMgb2YgY29ubmVjdGlvbiBzdGF0ZVxuICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfT1BFTjtcbiAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgLy8gUmVjZWl2ZWQgVENQIEZJTiwgc29ja2V0J3MgcmVhZGFibGUgc3RyZWFtIGlzIGZpbmlzaGVkLlxuICAgIHRoaXMucmVjZWl2ZWRFbmQgPSBmYWxzZTtcblxuICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gdGhpcy5jb25maWcuY2xvc2VUaW1lb3V0O1xuICAgIHRoaXMuYXNzZW1ibGVGcmFnbWVudHMgPSB0aGlzLmNvbmZpZy5hc3NlbWJsZUZyYWdtZW50cztcbiAgICB0aGlzLm1heFJlY2VpdmVkTWVzc2FnZVNpemUgPSB0aGlzLmNvbmZpZy5tYXhSZWNlaXZlZE1lc3NhZ2VTaXplO1xuXG4gICAgdGhpcy5vdXRwdXRCdWZmZXJGdWxsID0gZmFsc2U7XG4gICAgdGhpcy5pbnB1dFBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVjZWl2ZWREYXRhSGFuZGxlciA9IHRoaXMucHJvY2Vzc1JlY2VpdmVkRGF0YS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2Nsb3NlVGltZXJIYW5kbGVyID0gdGhpcy5oYW5kbGVDbG9zZVRpbWVyLmJpbmQodGhpcyk7XG5cbiAgICAvLyBEaXNhYmxlIG5hZ2xlIGFsZ29yaXRobT9cbiAgICB0aGlzLnNvY2tldC5zZXROb0RlbGF5KHRoaXMuY29uZmlnLmRpc2FibGVOYWdsZUFsZ29yaXRobSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgbm8gc29ja2V0IGluYWN0aXZpdHkgdGltZW91dFxuICAgIHRoaXMuc29ja2V0LnNldFRpbWVvdXQoMCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcua2VlcGFsaXZlICYmICF0aGlzLmNvbmZpZy51c2VOYXRpdmVLZWVwYWxpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlZXBhbGl2ZUludGVydmFsIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBudW1lcmljICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZiBrZWVwYWxpdmUgaXMgdHJ1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9rZWVwYWxpdmVUaW1lckhhbmRsZXIgPSB0aGlzLmhhbmRsZUtlZXBhbGl2ZVRpbWVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0S2VlcGFsaXZlVGltZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodGhpcy5jb25maWcua2VlcGFsaXZlR3JhY2VQZXJpb2QpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2VlcGFsaXZlR3JhY2VQZXJpb2QgIG11c3QgYmUgc3BlY2lmaWVkIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bWVyaWMgaWYgZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcyB0cnVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZ3JhY2VQZXJpb2RUaW1lckhhbmRsZXIgPSB0aGlzLmhhbmRsZUdyYWNlUGVyaW9kVGltZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy5rZWVwYWxpdmUgJiYgdGhpcy5jb25maWcudXNlTmF0aXZlS2VlcGFsaXZlKSB7XG4gICAgICAgIGlmICghKCdzZXRLZWVwQWxpdmUnIGluIHRoaXMuc29ja2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdXNlIG5hdGl2ZSBrZWVwYWxpdmU6IHVuc3VwcG9ydGVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aGlzIHZlcnNpb24gb2YgTm9kZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwgdGhpcy5jb25maWcua2VlcGFsaXZlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUaGUgSFRUUCBDbGllbnQgc2VlbXMgdG8gc3Vic2NyaWJlIHRvIHNvY2tldCBlcnJvciBldmVudHNcbiAgICAvLyBhbmQgcmUtZGlzcGF0Y2ggdGhlbSBpbiBzdWNoIGEgd2F5IHRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gZm9yIHVzZXJzIG9mIG91ciBjbGllbnQsIHNvIHdlIHdhbnQgdG8gbWFrZSBzdXJlIG5vYm9keVxuICAgIC8vIGVsc2UgaXMgbGlzdGVuaW5nIGZvciBlcnJvciBldmVudHMgb24gdGhlIHNvY2tldCBiZXNpZGVzIHVzLlxuICAgIHRoaXMuc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbn1cblxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMID0gMTAwMDtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0dPSU5HX0FXQVkgPSAxMDAxO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IgPSAxMDAyO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fVU5QUk9DRVNTQUJMRV9JTlBVVCA9IDEwMDM7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9SRVNFUlZFRCA9IDEwMDQ7IC8vIFJlc2VydmVkIHZhbHVlLiAgVW5kZWZpbmVkIG1lYW5pbmcuXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1RfUFJPVklERUQgPSAxMDA1OyAvLyBOb3QgdG8gYmUgdXNlZCBvbiB0aGUgd2lyZVxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUwgPSAxMDA2OyAvLyBOb3QgdG8gYmUgdXNlZCBvbiB0aGUgd2lyZVxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBID0gMTAwNztcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BPTElDWV9WSU9MQVRJT04gPSAxMDA4O1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTUVTU0FHRV9UT09fQklHID0gMTAwOTtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0VYVEVOU0lPTl9SRVFVSVJFRCA9IDEwMTA7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlRFUk5BTF9TRVJWRVJfRVJST1IgPSAxMDExO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fVExTX0hBTkRTSEFLRV9GQUlMRUQgPSAxMDE1OyAvLyBOb3QgdG8gYmUgdXNlZCBvbiB0aGUgd2lyZVxuXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OUyA9IHtcbiAgICAxMDAwOiAnTm9ybWFsIGNvbm5lY3Rpb24gY2xvc3VyZScsXG4gICAgMTAwMTogJ1JlbW90ZSBwZWVyIGlzIGdvaW5nIGF3YXknLFxuICAgIDEwMDI6ICdQcm90b2NvbCBlcnJvcicsXG4gICAgMTAwMzogJ1VucHJvY2Vzc2FibGUgaW5wdXQnLFxuICAgIDEwMDQ6ICdSZXNlcnZlZCcsXG4gICAgMTAwNTogJ1JlYXNvbiBub3QgcHJvdmlkZWQnLFxuICAgIDEwMDY6ICdBYm5vcm1hbCBjbG9zdXJlLCBubyBmdXJ0aGVyIGRldGFpbCBhdmFpbGFibGUnLFxuICAgIDEwMDc6ICdJbnZhbGlkIGRhdGEgcmVjZWl2ZWQnLFxuICAgIDEwMDg6ICdQb2xpY3kgdmlvbGF0aW9uJyxcbiAgICAxMDA5OiAnTWVzc2FnZSB0b28gYmlnJyxcbiAgICAxMDEwOiAnRXh0ZW5zaW9uIHJlcXVlc3RlZCBieSBjbGllbnQgaXMgcmVxdWlyZWQnLFxuICAgIDEwMTE6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDEwMTU6ICdUTFMgSGFuZHNoYWtlIEZhaWxlZCdcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xvc2VSZWFzb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgMTAwMCkge1xuICAgICAgICAvLyBTdGF0dXMgY29kZXMgaW4gdGhlIHJhbmdlIDAtOTk5IGFyZSBub3QgdXNlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDEwMDAgJiYgY29kZSA8PSAyOTk5KSB7XG4gICAgICAgIC8vIENvZGVzIGZyb20gMTAwMCAtIDI5OTkgYXJlIHJlc2VydmVkIGZvciB1c2UgYnkgdGhlIHByb3RvY29sLiAgT25seVxuICAgICAgICAvLyBhIGZldyBjb2RlcyBhcmUgZGVmaW5lZCwgYWxsIG90aGVycyBhcmUgY3VycmVudGx5IGlsbGVnYWwuXG4gICAgICAgIHJldHVybiBbMTAwMCwgMTAwMSwgMTAwMiwgMTAwMywgMTAwNywgMTAwOCwgMTAwOSwgMTAxMCwgMTAxMSwgMTAxMiwgMTAxMywgMTAxNCwgMTAxNV0uaW5kZXhPZihjb2RlKSAhPT0gLTE7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSAzOTk5KSB7XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciB1c2UgYnkgbGlicmFyaWVzLCBmcmFtZXdvcmtzLCBhbmQgYXBwbGljYXRpb25zLlxuICAgICAgICAvLyBTaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIElBTkEuICBJbnRlcnByZXRhdGlvbiBvZiB0aGVzZSBjb2RlcyBpc1xuICAgICAgICAvLyB1bmRlZmluZWQgYnkgdGhlIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDQwMDAgJiYgY29kZSA8PSA0OTk5KSB7XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBwcml2YXRlIHVzZS4gIEludGVycHJldGF0aW9uIG9mIHRoZXNlIGNvZGVzIGlzXG4gICAgICAgIC8vIHVuZGVmaW5lZCBieSB0aGUgV2ViU29ja2V0IHByb3RvY29sLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gNTAwMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLl9hZGRTb2NrZXRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuaGFuZGxlU29ja2V0RXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2VuZCcsIHRoaXMuaGFuZGxlU29ja2V0RW5kLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuaGFuZGxlU29ja2V0Q2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2RyYWluJywgdGhpcy5oYW5kbGVTb2NrZXREcmFpbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbigncGF1c2UnLCB0aGlzLmhhbmRsZVNvY2tldFBhdXNlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdyZXN1bWUnLCB0aGlzLmhhbmRsZVNvY2tldFJlc3VtZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignZGF0YScsIHRoaXMuaGFuZGxlU29ja2V0RGF0YS5iaW5kKHRoaXMpKTtcbn07XG5cbi8vIHNldCBvciByZXNldCB0aGUga2VlcGFsaXZlIHRpbWVyIHdoZW4gZGF0YSBpcyByZWNlaXZlZC5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNldEtlZXBhbGl2ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NldEtlZXBhbGl2ZVRpbWVyJyk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5rZWVwYWxpdmUgIHx8IHRoaXMuY29uZmlnLnVzZU5hdGl2ZUtlZXBhbGl2ZSkgeyByZXR1cm47IH1cbiAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIHRoaXMuX2tlZXBhbGl2ZVRpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy5fa2VlcGFsaXZlVGltZXJIYW5kbGVyLCB0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbGVhcktlZXBhbGl2ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2tlZXBhbGl2ZVRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fa2VlcGFsaXZlVGltZW91dElEKTtcbiAgICB9XG59O1xuXG4vLyBObyBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIHdpdGhpbiBjb25maWcua2VlcGFsaXZlVGltZW91dCBtcy5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUtlZXBhbGl2ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZUtlZXBhbGl2ZVRpbWVyJyk7XG4gICAgdGhpcy5fa2VlcGFsaXZlVGltZW91dElEID0gbnVsbDtcbiAgICB0aGlzLnBpbmcoKTtcblxuICAgIC8vIElmIHdlIGFyZSBjb25maWd1cmVkIHRvIGRyb3AgY29ubmVjdGlvbnMgaWYgdGhlIGNsaWVudCBkb2Vzbid0IHJlc3BvbmRcbiAgICAvLyB0aGVuIHNldCB0aGUgZ3JhY2UgcGVyaW9kIHRpbWVyLlxuICAgIGlmICh0aGlzLmNvbmZpZy5kcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCkge1xuICAgICAgICB0aGlzLnNldEdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCB0aGUga2VlcGFsaXZlIHRpbWVyIHRvIHNlbmQgdGhlIG5leHQgcGluZy5cbiAgICAgICAgdGhpcy5zZXRLZWVwYWxpdmVUaW1lcigpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNldEdyYWNlUGVyaW9kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0R3JhY2VQZXJpb2RUaW1lcicpO1xuICAgIHRoaXMuY2xlYXJHcmFjZVBlcmlvZFRpbWVyKCk7XG4gICAgdGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHRoaXMuX2dyYWNlUGVyaW9kVGltZXJIYW5kbGVyLCB0aGlzLmNvbmZpZy5rZWVwYWxpdmVHcmFjZVBlcmlvZCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbGVhckdyYWNlUGVyaW9kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyYWNlUGVyaW9kVGltZW91dElEKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVHcmFjZVBlcmlvZFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZUdyYWNlUGVyaW9kVGltZXInKTtcbiAgICAvLyBJZiB0aGlzIGlzIGNhbGxlZCwgdGhlIGNsaWVudCBoYXMgbm90IHJlc3BvbmRlZCBhbmQgaXMgYXNzdW1lZCBkZWFkLlxuICAgIHRoaXMuX2dyYWNlUGVyaW9kVGltZW91dElEID0gbnVsbDtcbiAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUwsICdQZWVyIG5vdCByZXNwb25kaW5nLicsIHRydWUpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RGF0YScpO1xuICAgIC8vIFJlc2V0IHRoZSBrZWVwYWxpdmUgdGltZXIgd2hlbiByZWNlaXZpbmcgZGF0YSBvZiBhbnkga2luZC5cbiAgICB0aGlzLnNldEtlZXBhbGl2ZVRpbWVyKCk7XG5cbiAgICAvLyBBZGQgcmVjZWl2ZWQgZGF0YSB0byBvdXIgYnVmZmVyTGlzdCwgd2hpY2ggZWZmaWNpZW50bHkgaG9sZHMgcmVjZWl2ZWRcbiAgICAvLyBkYXRhIGNodW5rcyBpbiBhIGxpbmtlZCBsaXN0IG9mIEJ1ZmZlciBvYmplY3RzLlxuICAgIHRoaXMuYnVmZmVyTGlzdC53cml0ZShkYXRhKTtcblxuICAgIHRoaXMucHJvY2Vzc1JlY2VpdmVkRGF0YSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc1JlY2VpdmVkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdwcm9jZXNzUmVjZWl2ZWREYXRhJyk7XG4gICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2Ugc2hvdWxkIGlnbm9yZSBhbnkgZGF0YSByZW1haW5pbmcgb24gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7IHJldHVybjsgfVxuXG4gICAgLy8gUmVjZWl2aW5nL3BhcnNpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaGFsdGVkIHdoZW4gcGF1c2VkLlxuICAgIGlmICh0aGlzLmlucHV0UGF1c2VkKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cbiAgICAvLyBXZWJTb2NrZXRGcmFtZS5wcm90b3R5cGUuYWRkRGF0YSByZXR1cm5zIHRydWUgaWYgYWxsIGRhdGEgbmVjZXNzYXJ5IHRvXG4gICAgLy8gcGFyc2UgdGhlIGZyYW1lIHdhcyBhdmFpbGFibGUuICBJdCByZXR1cm5zIGZhbHNlIGlmIHdlIGFyZSB3YWl0aW5nIGZvclxuICAgIC8vIG1vcmUgZGF0YSB0byBjb21lIGluIG9uIHRoZSB3aXJlLlxuICAgIGlmICghZnJhbWUuYWRkRGF0YSh0aGlzLmJ1ZmZlckxpc3QpKSB7IHRoaXMuX2RlYnVnKCctLSBpbnN1ZmZpY2llbnQgZGF0YSBmb3IgZnJhbWUnKTsgcmV0dXJuOyB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBIYW5kbGUgcG9zc2libGUgcGFyc2luZyBlcnJvcnNcbiAgICBpZiAoZnJhbWUucHJvdG9jb2xFcnJvcikge1xuICAgICAgICAvLyBTb21ldGhpbmcgYmFkIGhhcHBlbmVkLi4gZ2V0IHJpZCBvZiB0aGlzIGNsaWVudC5cbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIHByb3RvY29sIGVycm9yJyk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsIGZyYW1lLmRyb3BSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChmcmFtZS5mcmFtZVRvb0xhcmdlKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBmcmFtZSB0b28gbGFyZ2UnKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9NRVNTQUdFX1RPT19CSUcsIGZyYW1lLmRyb3BSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvciBub3cgc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydCBleHRlbnNpb25zLCBhbGwgUlNWIGJpdHMgYXJlIGlsbGVnYWxcbiAgICBpZiAoZnJhbWUucnN2MSB8fCBmcmFtZS5yc3YyIHx8IGZyYW1lLnJzdjMpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIGlsbGVnYWwgcnN2IGZsYWcnKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIHVzYWdlIG9mIHJzdiBiaXRzIHdpdGhvdXQgbmVnb3RpYXRlZCBleHRlbnNpb24uJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBlbWl0dGluZyBmcmFtZScpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyBzZWxmLmVtaXQoJ2ZyYW1lJywgZnJhbWUpOyB9KTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyBzZWxmLnByb2Nlc3NGcmFtZShmcmFtZSk7IH0pO1xuICAgIFxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGRhdGEgcmVtYWluaW5nLCBzY2hlZHVsZSBhZGRpdGlvbmFsIHByb2Nlc3NpbmcsIGJ1dCB5aWVsZFxuICAgIC8vIGZvciBub3cgc28gdGhhdCBvdGhlciBjb25uZWN0aW9ucyBoYXZlIGEgY2hhbmNlIHRvIGhhdmUgdGhlaXIgZGF0YVxuICAgIC8vIHByb2Nlc3NlZC4gIFdlIHVzZSBzZXRJbW1lZGlhdGUgaGVyZSBpbnN0ZWFkIG9mIHByb2Nlc3MubmV4dFRpY2sgdG9cbiAgICAvLyBleHBsaWNpdGx5IGluZGljYXRlIHRoYXQgd2Ugd2lzaCBmb3Igb3RoZXIgSS9PIHRvIGJlIGhhbmRsZWQgZmlyc3QuXG4gICAgaWYgKHRoaXMuYnVmZmVyTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZUltcGwodGhpcy5yZWNlaXZlZERhdGFIYW5kbGVyKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldEVycm9yOiAlaicsIGVycm9yKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfQ0xPU0VEKSB7XG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMi9XZWJTb2NrZXQtTm9kZS9pc3N1ZXMvMjg4XG4gICAgICAgIHRoaXMuX2RlYnVnKCcgIC0tLSBTb2NrZXQgXFwnZXJyb3JcXCcgYWZ0ZXIgXFwnY2xvc2VcXCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMO1xuICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9ICdTb2NrZXQgRXJyb3I6ICcgKyBlcnJvci5zeXNjYWxsICsgJyAnICsgZXJyb3IuY29kZTtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7XG4gICAgaWYgKHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICB0aGlzLl9kZWJ1Zy5wcmludE91dHB1dCgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0RW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldEVuZDogcmVjZWl2ZWQgc29ja2V0IGVuZC4gIHN0YXRlID0gJXMnLCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLnJlY2VpdmVkRW5kID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfQ0xPU0VEKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgdGhlIFRMUyBtb2R1bGUsIHNvbWV0aW1lcyB0aGUgc29ja2V0IHdpbGwgZW1pdCAnZW5kJ1xuICAgICAgICAvLyBhZnRlciBpdCBlbWl0cyAnY2xvc2UnLiAgSSBkb24ndCB0aGluayB0aGF0J3MgY29ycmVjdCBiZWhhdmlvcixcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBkZWFsIHdpdGggaXQgZ3JhY2VmdWxseSBieSBpZ25vcmluZyBpdC5cbiAgICAgICAgdGhpcy5fZGVidWcoJyAgLS0tIFNvY2tldCBcXCdlbmRcXCcgYWZ0ZXIgXFwnY2xvc2VcXCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRU5ESU5HKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnICAtLS0gVU5FWFBFQ1RFRCBzb2NrZXQgZW5kLicpO1xuICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0Q2xvc2UgPSBmdW5jdGlvbihoYWRFcnJvcikge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRDbG9zZTogcmVjZWl2ZWQgc29ja2V0IGNsb3NlJyk7XG4gICAgdGhpcy5zb2NrZXRIYWRFcnJvciA9IGhhZEVycm9yO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICAvLyBJZiBjbG9zZVJlYXNvbkNvZGUgaXMgc3RpbGwgc2V0IHRvIC0xIGF0IHRoaXMgcG9pbnQgdGhlbiB3ZSBtdXN0XG4gICAgLy8gbm90IGhhdmUgcmVjZWl2ZWQgYSBjbG9zZSBmcmFtZSEhXG4gICAgaWYgKHRoaXMuY2xvc2VSZWFzb25Db2RlID09PSAtMSkge1xuICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMO1xuICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IHJlbW90ZSBwZWVyLic7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICBpZiAoIXRoaXMuY2xvc2VFdmVudEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBFbWl0dGluZyBXZWJTb2NrZXRDb25uZWN0aW9uIGNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLmNsb3NlUmVhc29uQ29kZSwgdGhpcy5jbG9zZURlc2NyaXB0aW9uKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXREcmFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXREcmFpbjogc29ja2V0IGRyYWluIGV2ZW50Jyk7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXJGdWxsID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0UGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0UGF1c2U6IHNvY2tldCBwYXVzZSBldmVudCcpO1xuICAgIHRoaXMuaW5wdXRQYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldFJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRSZXN1bWU6IHNvY2tldCByZXN1bWUgZXZlbnQnKTtcbiAgICB0aGlzLmlucHV0UGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgICB0aGlzLnByb2Nlc3NSZWNlaXZlZERhdGEoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3BhdXNlOiBwYXVzZSByZXF1ZXN0ZWQnKTtcbiAgICB0aGlzLnNvY2tldC5wYXVzZSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3Jlc3VtZTogcmVzdW1lIHJlcXVlc3RlZCcpO1xuICAgIHRoaXMuc29ja2V0LnJlc3VtZSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihyZWFzb25Db2RlLCBkZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnY2xvc2U6IEluaXRhdGluZyBjbGVhbiBXZWJTb2NrZXQgY2xvc2Ugc2VxdWVuY2UuJyk7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHJlYXNvbkNvZGUpIHtcbiAgICAgICAgICAgIHJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZGF0ZUNsb3NlUmVhc29uKHJlYXNvbkNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NlIGNvZGUgJyArIHJlYXNvbkNvZGUgKyAnIGlzIG5vdCB2YWxpZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OU1tyZWFzb25Db2RlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNldENsb3NlVGltZXIoKTtcbiAgICAgICAgdGhpcy5zZW5kQ2xvc2VGcmFtZSh0aGlzLmNsb3NlUmVhc29uQ29kZSwgdGhpcy5jbG9zZURlc2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0VORElORztcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24ocmVhc29uQ29kZSwgZGVzY3JpcHRpb24sIHNraXBDbG9zZUZyYW1lKSB7XG4gICAgdGhpcy5fZGVidWcoJ2Ryb3AnKTtcbiAgICBpZiAodHlwZW9mKHJlYXNvbkNvZGUpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1I7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihkZXNjcmlwdGlvbikgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIElmIG5vIGRlc2NyaXB0aW9uIGlzIHByb3ZpZGVkLCB0cnkgdG8gbG9vayBvbmUgdXAgYmFzZWQgb24gdGhlXG4gICAgICAgIC8vIHNwZWNpZmllZCByZWFzb25Db2RlLlxuICAgICAgICBkZXNjcmlwdGlvbiA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TW3JlYXNvbkNvZGVdO1xuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCdGb3JjZWZ1bGx5IGRyb3BwaW5nIGNvbm5lY3Rpb24uIHNraXBDbG9zZUZyYW1lOiAlcywgY29kZTogJWQsIGRlc2NyaXB0aW9uOiAlcycsXG4gICAgICAgIHNraXBDbG9zZUZyYW1lLCByZWFzb25Db2RlLCBkZXNjcmlwdGlvblxuICAgICk7XG5cbiAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgdGhpcy5mcmFtZVF1ZXVlID0gW107XG4gICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7XG4gICAgaWYgKCFza2lwQ2xvc2VGcmFtZSkge1xuICAgICAgICB0aGlzLnNlbmRDbG9zZUZyYW1lKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcblxuICAgIGlmICghdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCkge1xuICAgICAgICB0aGlzLmNsb3NlRXZlbnRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVidWcoJ0VtaXR0aW5nIFdlYlNvY2tldENvbm5lY3Rpb24gY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuY2xvc2VSZWFzb25Db2RlLCB0aGlzLmNsb3NlRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9kZWJ1ZygnRHJvcDogZGVzdHJveWluZyBzb2NrZXQnKTtcbiAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NldENsb3NlVGltZXInKTtcbiAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgIHRoaXMuX2RlYnVnKCdTZXR0aW5nIGNsb3NlIHRpbWVyJyk7XG4gICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IHRydWU7XG4gICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9jbG9zZVRpbWVySGFuZGxlciwgdGhpcy5jbG9zZVRpbWVvdXQpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xlYXJDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2NsZWFyQ2xvc2VUaW1lcicpO1xuICAgIGlmICh0aGlzLmNsb3NlVGltZXIpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ0NsZWFyaW5nIGNsb3NlIHRpbWVyJyk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlQ2xvc2VUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVDbG9zZVRpbWVyJyk7XG4gICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcbiAgICBpZiAodGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnQ2xvc2UgcmVzcG9uc2Ugbm90IHJlY2VpdmVkIGZyb20gY2xpZW50LiAgRm9yY2luZyBzb2NrZXQgZW5kLicpO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnByb2Nlc3NGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgdGhpcy5fZGVidWcoJ3Byb2Nlc3NGcmFtZScpO1xuICAgIHRoaXMuX2RlYnVnKCcgLS0gZnJhbWU6ICVzJywgZnJhbWUpO1xuICAgIFxuICAgIC8vIEFueSBub24tY29udHJvbCBvcGNvZGUgYmVzaWRlcyAweDAwIChjb250aW51YXRpb24pIHJlY2VpdmVkIGluIHRoZVxuICAgIC8vIG1pZGRsZSBvZiBhIGZyYWdtZW50ZWQgbWVzc2FnZSBpcyBpbGxlZ2FsLlxuICAgIGlmICh0aGlzLmZyYW1lUXVldWUubGVuZ3RoICE9PSAwICYmIChmcmFtZS5vcGNvZGUgPiAweDAwICYmIGZyYW1lLm9wY29kZSA8IDB4MDgpKSB7XG4gICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAnSWxsZWdhbCBmcmFtZSBvcGNvZGUgMHgnICsgZnJhbWUub3Bjb2RlLnRvU3RyaW5nKDE2KSArICcgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkIGluIG1pZGRsZSBvZiBmcmFnbWVudGVkIG1lc3NhZ2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2goZnJhbWUub3Bjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMjogLy8gV2ViU29ja2V0RnJhbWUuQklOQVJZX0ZSQU1FXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gQmluYXJ5IEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgc2luZ2xlLWZyYW1lIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gRW1pdHRpbmcgXFwnbWVzc2FnZVxcJyBldmVudCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmluYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeURhdGE6IGZyYW1lLmJpbmFyeVBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgYSBmcmFnbWVudGVkIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDE6IC8vIFdlYlNvY2tldEZyYW1lLlRFWFRfRlJBTUVcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBUZXh0IEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChmcmFtZS5iaW5hcnlQYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgVVRGLTggRGF0YSBSZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIHNpbmdsZS1mcmFtZSBtZXNzYWdlIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIEVtaXR0aW5nIFxcJ21lc3NhZ2VcXCcgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3V0ZjgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRmOERhdGE6IGZyYW1lLmJpbmFyeVBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiBhIGZyYWdtZW50ZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMDogLy8gV2ViU29ja2V0RnJhbWUuQ09OVElOVUFUSU9OXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gQ29udGludWF0aW9uIEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBDb250aW51YXRpb24gRnJhbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgKz0gZnJhbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPiB0aGlzLm1heFJlY2VpdmVkTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRyxcbiAgICAgICAgICAgICAgICAgICAgICAnTWF4aW11bSBtZXNzYWdlIHNpemUgZXhjZWVkZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUucHVzaChmcmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUuZmluKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBmcmFnbWVudGVkIG1lc3NhZ2UsIHNvIHdlIHByb2Nlc3MgdGhlIHdob2xlXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2Ugbm93LiAgV2UgYWxzbyBoYXZlIHRvIGRlY29kZSB0aGUgdXRmLTggZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGV4dCBmcmFtZXMgYWZ0ZXIgY29tYmluaW5nIGFsbCB0aGUgZnJhZ21lbnRzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMuZnJhZ21lbnRhdGlvblNpemUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3Bjb2RlID0gdGhpcy5mcmFtZVF1ZXVlWzBdLm9wY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmJpbmFyeVBheWxvYWQuY29weShiaW5hcnlQYXlsb2FkLCBieXRlc0NvcGllZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0NvcGllZCArPSBjdXJyZW50RnJhbWUuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMjogLy8gV2ViU29ja2V0T3Bjb2RlLkJJTkFSWV9GUkFNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JpbmFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeURhdGE6IGJpbmFyeVBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMTogLy8gV2ViU29ja2V0T3Bjb2RlLlRFWFRfRlJBTUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGJpbmFyeVBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgVVRGLTggRGF0YSBSZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3V0ZjgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4RGF0YTogYmluYXJ5UGF5bG9hZC50b1N0cmluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGZpcnN0IG9wY29kZSBpbiBmcmFnbWVudGF0aW9uIHNlcXVlbmNlOiAweCcgKyBvcGNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvLyBXZWJTb2NrZXRGcmFtZS5QSU5HXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gUGluZyBGcmFtZScpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGluZ0xpc3RlbmVyQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9naWMgdG8gZW1pdCB0aGUgcGluZyBmcmFtZTogdGhpcyBpcyBvbmx5IGRvbmUgd2hlbiBhIGxpc3RlbmVyIGlzIGtub3duIHRvIGV4aXN0XG4gICAgICAgICAgICAgICAgLy8gRXhwb3NlIGEgZnVuY3Rpb24gYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlOyBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycsIGNhbmNlbCwgZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNlbmQgYSBwb25nIGlmIHRoZSBjbGllbnQgZGlkIG5vdCBpbmRpY2F0ZSB0aGF0IGhlIHdvdWxkIGxpa2UgdG8gY2FuY2VsXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb25nKGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9uZyhmcmFtZS5iaW5hcnlQYXlsb2FkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwQTogLy8gV2ViU29ja2V0RnJhbWUuUE9OR1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIFBvbmcgRnJhbWUnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycsIGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwODogLy8gV2ViU29ja2V0RnJhbWUuQ09OTkVDVElPTl9DTE9TRVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIENsb3NlIEZyYW1lJyk7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vIEdvdCByZXNwb25zZSB0byBvdXIgcmVxdWVzdCB0byBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBpcyBjb21wbGV0ZSwgc28gd2UganVzdCBoYW5nIHVwLlxuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIEdvdCBjbG9zZSByZXNwb25zZSBmcm9tIHBlZXIuICBDb21wbGV0aW5nIGNsb3NpbmcgaGFuZHNoYWtlLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLSBDbG9zaW5nIGhhbmRzaGFrZSBpbml0aWF0ZWQgYnkgcGVlci4nKTtcbiAgICAgICAgICAgIC8vIEdvdCByZXF1ZXN0IGZyb20gb3RoZXIgcGFydHkgdG8gY2xvc2UgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIC8vIFNlbmQgYmFjayBhY2tub3dsZWRnZW1lbnQgYW5kIHRoZW4gaGFuZyB1cC5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRTtcbiAgICAgICAgICAgIHZhciByZXNwb25kQ2xvc2VSZWFzb25Db2RlO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNsb3NlIHJlYXNvbiBwcm92aWRlZCBpcyBsZWdhbCBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIHRoZSBwcm90b2NvbCBzcGVjLiAgUHJvdmlkaW5nIG5vIGNsb3NlIHN0YXR1cyBpcyBsZWdhbC5cbiAgICAgICAgICAgIC8vIFdlYlNvY2tldEZyYW1lIHNldHMgY2xvc2VTdGF0dXMgdG8gLTEgYnkgZGVmYXVsdCwgc28gaWYgaXRcbiAgICAgICAgICAgIC8vIGlzIHN0aWxsIC0xLCB0aGVuIG5vIHN0YXR1cyB3YXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBpZiAoZnJhbWUuaW52YWxpZENsb3NlRnJhbWVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IDEwMDU7IC8vIDEwMDUgPSBObyByZWFzb24gcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgcmVzcG9uZENsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhbWUuY2xvc2VTdGF0dXMgPT09IC0xIHx8IHZhbGlkYXRlQ2xvc2VSZWFzb24oZnJhbWUuY2xvc2VTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSBmcmFtZS5jbG9zZVN0YXR1cztcbiAgICAgICAgICAgICAgICByZXNwb25kQ2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSBmcmFtZS5jbG9zZVN0YXR1cztcbiAgICAgICAgICAgICAgICByZXNwb25kQ2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdGV4dHVhbCBkZXNjcmlwdGlvbiBpbiB0aGUgY2xvc2UgZnJhbWUsIGV4dHJhY3QgaXQuXG4gICAgICAgICAgICBpZiAoZnJhbWUuYmluYXJ5UGF5bG9hZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChmcmFtZS5iaW5hcnlQYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFVURi04IERhdGEgUmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBmcmFtZS5iaW5hcnlQYXlsb2FkLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OU1t0aGlzLmNsb3NlUmVhc29uQ29kZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICAgICAnLS0tLS0tIFJlbW90ZSBwZWVyICVzIC0gY29kZTogJWQgLSAlcyAtIGNsb3NlIGZyYW1lIHBheWxvYWQgbGVuZ3RoOiAlZCcsXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzLCB0aGlzLmNsb3NlUmVhc29uQ29kZSxcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24sIGZyYW1lLmxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tLS0gcmVzcG9uZGluZyB0byByZW1vdGUgcGVlclxcJ3MgY2xvc2UgcmVxdWVzdC4nKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZENsb3NlRnJhbWUocmVzcG9uZENsb3NlUmVhc29uQ29kZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gVW5yZWNvZ25pemVkIE9wY29kZSAlZCcsIGZyYW1lLm9wY29kZSk7XG4gICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgICAgICdVbnJlY29nbml6ZWQgT3Bjb2RlOiAweCcgKyBmcmFtZS5vcGNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhLCBjYikge1xuICAgIHRoaXMuX2RlYnVnKCdzZW5kJyk7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICB0aGlzLnNlbmRCeXRlcyhkYXRhLCBjYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihkYXRhWyd0b1N0cmluZyddKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnNlbmRVVEYoZGF0YSwgY2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHByb3ZpZGVkIG11c3QgZWl0aGVyIGJlIGEgTm9kZSBCdWZmZXIgb3IgaW1wbGVtZW50IHRvU3RyaW5nKCknKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kVVRGID0gZnVuY3Rpb24oZGF0YSwgY2IpIHtcbiAgICBkYXRhID0gYnVmZmVyRnJvbVN0cmluZyhkYXRhLnRvU3RyaW5nKCksICd1dGY4Jyk7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmRVVEY6ICVkIGJ5dGVzJywgZGF0YS5sZW5ndGgpO1xuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDE7IC8vIFdlYlNvY2tldE9wY29kZS5URVhUX0ZSQU1FXG4gICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGRhdGE7XG4gICAgdGhpcy5mcmFnbWVudEFuZFNlbmQoZnJhbWUsIGNiKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRCeXRlcyA9IGZ1bmN0aW9uKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmRCeXRlcycpO1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcGFzcyBhIE5vZGUgQnVmZmVyIG9iamVjdCB0byBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kQnl0ZXMoKScpO1xuICAgIH1cbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDAyOyAvLyBXZWJTb2NrZXRPcGNvZGUuQklOQVJZX0ZSQU1FXG4gICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGRhdGE7XG4gICAgdGhpcy5mcmFnbWVudEFuZFNlbmQoZnJhbWUsIGNiKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5fZGVidWcoJ3BpbmcnKTtcbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDA5OyAvLyBXZWJTb2NrZXRPcGNvZGUuUElOR1xuICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBidWZmZXJGcm9tU3RyaW5nKGRhdGEudG9TdHJpbmcoKSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxMjUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdXZWJTb2NrZXQ6IERhdGEgZm9yIHBpbmcgaXMgbG9uZ2VyIHRoYW4gMTI1IGJ5dGVzLiAgVHJ1bmNhdGluZy4nKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsMTI0KTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gZGF0YTtcbiAgICB9XG4gICAgdGhpcy5zZW5kRnJhbWUoZnJhbWUpO1xufTtcblxuLy8gUG9uZyBmcmFtZXMgaGF2ZSB0byBlY2hvIGJhY2sgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHBvcnRpb24gb2YgdGhlXG4vLyBwaW5nIGZyYW1lIGV4YWN0bHksIGJ5dGUgZm9yIGJ5dGUuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5wb25nID0gZnVuY3Rpb24oYmluYXJ5UGF5bG9hZCkge1xuICAgIHRoaXMuX2RlYnVnKCdwb25nJyk7XG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwQTsgLy8gV2ViU29ja2V0T3Bjb2RlLlBPTkdcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJpbmFyeVBheWxvYWQpICYmIGJpbmFyeVBheWxvYWQubGVuZ3RoID4gMTI1KSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdXZWJTb2NrZXQ6IERhdGEgZm9yIHBvbmcgaXMgbG9uZ2VyIHRoYW4gMTI1IGJ5dGVzLiAgVHJ1bmNhdGluZy4nKTtcbiAgICAgICAgYmluYXJ5UGF5bG9hZCA9IGJpbmFyeVBheWxvYWQuc2xpY2UoMCwxMjQpO1xuICAgIH1cbiAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gYmluYXJ5UGF5bG9hZDtcbiAgICBmcmFtZS5maW4gPSB0cnVlO1xuICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmZyYWdtZW50QW5kU2VuZCA9IGZ1bmN0aW9uKGZyYW1lLCBjYikge1xuICAgIHRoaXMuX2RlYnVnKCdmcmFnbWVudEFuZFNlbmQnKTtcbiAgICBpZiAoZnJhbWUub3Bjb2RlID4gMHgwNykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZnJhZ21lbnQgY29udHJvbCBmcmFtZXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMuY29uZmlnLmZyYWdtZW50YXRpb25UaHJlc2hvbGQ7XG4gICAgdmFyIGxlbmd0aCA9IGZyYW1lLmJpbmFyeVBheWxvYWQubGVuZ3RoO1xuXG4gICAgLy8gU2VuZCBpbW1lZGlhdGVseSBpZiBmcmFnbWVudGF0aW9uIGlzIGRpc2FibGVkIG9yIHRoZSBtZXNzYWdlIGlzIG5vdFxuICAgIC8vIGxhcmdlciB0aGFuIHRoZSBmcmFnbWVudGF0aW9uIHRocmVzaG9sZC5cbiAgICBpZiAoIXRoaXMuY29uZmlnLmZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyB8fCAoZnJhbWUuYmluYXJ5UGF5bG9hZCAmJiBsZW5ndGggPD0gdGhyZXNob2xkKSkge1xuICAgICAgICBmcmFtZS5maW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBudW1GcmFnbWVudHMgPSBNYXRoLmNlaWwobGVuZ3RoIC8gdGhyZXNob2xkKTtcbiAgICB2YXIgc2VudEZyYWdtZW50cyA9IDA7XG4gICAgdmFyIHNlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIGZyYWdtZW50U2VudENhbGxiYWNrKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFzcyBvbmx5IHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICsrc2VudEZyYWdtZW50cztcbiAgICAgICAgaWYgKChzZW50RnJhZ21lbnRzID09PSBudW1GcmFnbWVudHMpICYmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpPTE7IGkgPD0gbnVtRnJhZ21lbnRzOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgICAgICBcbiAgICAgICAgLy8gY29udGludWF0aW9uIG9wY29kZSBleGNlcHQgZm9yIGZpcnN0IGZyYW1lLlxuICAgICAgICBjdXJyZW50RnJhbWUub3Bjb2RlID0gKGkgPT09IDEpID8gZnJhbWUub3Bjb2RlIDogMHgwMDtcbiAgICAgICAgXG4gICAgICAgIC8vIGZpbiBzZXQgb24gbGFzdCBmcmFtZSBvbmx5XG4gICAgICAgIGN1cnJlbnRGcmFtZS5maW4gPSAoaSA9PT0gbnVtRnJhZ21lbnRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGxlbmd0aCBpcyBsaWtlbHkgdG8gYmUgc2hvcnRlciBvbiB0aGUgbGFzdCBmcmFnbWVudFxuICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IChpID09PSBudW1GcmFnbWVudHMpID8gbGVuZ3RoIC0gKHRocmVzaG9sZCAqIChpLTEpKSA6IHRocmVzaG9sZDtcbiAgICAgICAgdmFyIHNsaWNlU3RhcnQgPSB0aHJlc2hvbGQgKiAoaS0xKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNsaWNlIHRoZSByaWdodCBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCBwYXlsb2FkXG4gICAgICAgIGN1cnJlbnRGcmFtZS5iaW5hcnlQYXlsb2FkID0gZnJhbWUuYmluYXJ5UGF5bG9hZC5zbGljZShzbGljZVN0YXJ0LCBzbGljZVN0YXJ0ICsgY3VycmVudExlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNlbmRGcmFtZShjdXJyZW50RnJhbWUsIHNlbnRDYWxsYmFjayk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZENsb3NlRnJhbWUgPSBmdW5jdGlvbihyZWFzb25Db2RlLCBkZXNjcmlwdGlvbiwgY2IpIHtcbiAgICBpZiAodHlwZW9mKHJlYXNvbkNvZGUpICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZENsb3NlRnJhbWUgc3RhdGU6ICVzLCByZWFzb25Db2RlOiAlZCwgZGVzY3JpcHRpb246ICVzJywgdGhpcy5zdGF0ZSwgcmVhc29uQ29kZSwgZGVzY3JpcHRpb24pO1xuICAgIFxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9PUEVOICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFKSB7IHJldHVybjsgfVxuICAgIFxuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwODsgLy8gV2ViU29ja2V0T3Bjb2RlLkNPTk5FQ1RJT05fQ0xPU0VcbiAgICBmcmFtZS5jbG9zZVN0YXR1cyA9IHJlYXNvbkNvZGU7XG4gICAgaWYgKHR5cGVvZihkZXNjcmlwdGlvbikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBidWZmZXJGcm9tU3RyaW5nKGRlc2NyaXB0aW9uLCAndXRmOCcpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSwgY2IpO1xuICAgIHRoaXMuc29ja2V0LmVuZCgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmRGcmFtZScpO1xuICAgIGZyYW1lLm1hc2sgPSB0aGlzLm1hc2tPdXRnb2luZ1BhY2tldHM7XG4gICAgdmFyIGZsdXNoZWQgPSB0aGlzLnNvY2tldC53cml0ZShmcmFtZS50b0J1ZmZlcigpLCBjYik7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXJGdWxsID0gIWZsdXNoZWQ7XG4gICAgcmV0dXJuIGZsdXNoZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldENvbm5lY3Rpb247XG5cblxuXG5mdW5jdGlvbiBpbnN0cnVtZW50U29ja2V0Rm9yRGVidWdnaW5nKGNvbm5lY3Rpb24sIHNvY2tldCkge1xuICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgIGlmICghY29ubmVjdGlvbi5fZGVidWcuZW5hYmxlZCkgeyByZXR1cm47IH1cbiAgICBcbiAgICB2YXIgb3JpZ2luYWxTb2NrZXRFbWl0ID0gc29ja2V0LmVtaXQ7XG4gICAgc29ja2V0LmVtaXQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBjb25uZWN0aW9uLl9kZWJ1ZygnfHx8IFNvY2tldCBFdmVudCAgXFwnJXNcXCcnLCBldmVudCk7XG4gICAgICAgIG9yaWdpbmFsU29ja2V0RW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgXG4gICAgZm9yICh2YXIga2V5IGluIHNvY2tldCkge1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mKHNvY2tldFtrZXldKSkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoWydlbWl0J10uaW5kZXhPZihrZXkpICE9PSAtMSkgeyBjb250aW51ZTsgfVxuICAgICAgICAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBzb2NrZXRba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXRba2V5XSA9IGZ1bmN0aW9uIHByb3h5TWV0aG9kX19FdmVudEVtaXR0ZXJfX09uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLl9kZWJ1ZygnfHx8IFNvY2tldCBtZXRob2QgY2FsbGVkOiAgJXMgKCVzKScsIGtleSwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXRba2V5XSA9IGZ1bmN0aW9uIHByb3h5TWV0aG9kKCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uX2RlYnVnKCd8fHwgU29ja2V0IG1ldGhvZCBjYWxsZWQ6ICAlcycsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShrZXkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsInV0aWxzIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0RnJhbWUiLCJCdWZmZXJMaXN0IiwiaXNWYWxpZFVURjgiLCJidWZmZXJBbGxvY1Vuc2FmZSIsImJ1ZmZlckZyb21TdHJpbmciLCJTVEFURV9PUEVOIiwiU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UiLCJTVEFURV9FTkRJTkciLCJTVEFURV9DTE9TRUQiLCJzZXRJbW1lZGlhdGVJbXBsIiwiZ2xvYmFsIiwic2V0SW1tZWRpYXRlIiwiYmluZCIsInByb2Nlc3MiLCJuZXh0VGljayIsImlkQ291bnRlciIsIldlYlNvY2tldENvbm5lY3Rpb24iLCJzb2NrZXQiLCJleHRlbnNpb25zIiwicHJvdG9jb2wiLCJtYXNrT3V0Z29pbmdQYWNrZXRzIiwiY29uZmlnIiwiX2RlYnVnIiwiQnVmZmVyaW5nTG9nZ2VyIiwiZW5hYmxlZCIsImluc3RydW1lbnRTb2NrZXRGb3JEZWJ1Z2dpbmciLCJjYWxsIiwiX3BpbmdMaXN0ZW5lckNvdW50Iiwib24iLCJldiIsInJlbW90ZUFkZHJlc3MiLCJjbG9zZVJlYXNvbkNvZGUiLCJjbG9zZURlc2NyaXB0aW9uIiwiY2xvc2VFdmVudEVtaXR0ZWQiLCJtYXNrQnl0ZXMiLCJmcmFtZUhlYWRlciIsImJ1ZmZlckxpc3QiLCJjdXJyZW50RnJhbWUiLCJmcmFnbWVudGF0aW9uU2l6ZSIsImZyYW1lUXVldWUiLCJjb25uZWN0ZWQiLCJzdGF0ZSIsIndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlIiwicmVjZWl2ZWRFbmQiLCJjbG9zZVRpbWVvdXQiLCJhc3NlbWJsZUZyYWdtZW50cyIsIm1heFJlY2VpdmVkTWVzc2FnZVNpemUiLCJvdXRwdXRCdWZmZXJGdWxsIiwiaW5wdXRQYXVzZWQiLCJyZWNlaXZlZERhdGFIYW5kbGVyIiwicHJvY2Vzc1JlY2VpdmVkRGF0YSIsIl9jbG9zZVRpbWVySGFuZGxlciIsImhhbmRsZUNsb3NlVGltZXIiLCJzZXROb0RlbGF5IiwiZGlzYWJsZU5hZ2xlQWxnb3JpdGhtIiwic2V0VGltZW91dCIsImtlZXBhbGl2ZSIsInVzZU5hdGl2ZUtlZXBhbGl2ZSIsImtlZXBhbGl2ZUludGVydmFsIiwiRXJyb3IiLCJfa2VlcGFsaXZlVGltZXJIYW5kbGVyIiwiaGFuZGxlS2VlcGFsaXZlVGltZXIiLCJzZXRLZWVwYWxpdmVUaW1lciIsImRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0Iiwia2VlcGFsaXZlR3JhY2VQZXJpb2QiLCJfZ3JhY2VQZXJpb2RUaW1lckhhbmRsZXIiLCJoYW5kbGVHcmFjZVBlcmlvZFRpbWVyIiwic2V0S2VlcEFsaXZlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiQ0xPU0VfUkVBU09OX05PUk1BTCIsIkNMT1NFX1JFQVNPTl9HT0lOR19BV0FZIiwiQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SIiwiQ0xPU0VfUkVBU09OX1VOUFJPQ0VTU0FCTEVfSU5QVVQiLCJDTE9TRV9SRUFTT05fUkVTRVJWRUQiLCJDTE9TRV9SRUFTT05fTk9UX1BST1ZJREVEIiwiQ0xPU0VfUkVBU09OX0FCTk9STUFMIiwiQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSIsIkNMT1NFX1JFQVNPTl9QT0xJQ1lfVklPTEFUSU9OIiwiQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRyIsIkNMT1NFX1JFQVNPTl9FWFRFTlNJT05fUkVRVUlSRUQiLCJDTE9TRV9SRUFTT05fSU5URVJOQUxfU0VSVkVSX0VSUk9SIiwiQ0xPU0VfUkVBU09OX1RMU19IQU5EU0hBS0VfRkFJTEVEIiwiQ0xPU0VfREVTQ1JJUFRJT05TIiwidmFsaWRhdGVDbG9zZVJlYXNvbiIsImNvZGUiLCJpbmRleE9mIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJfYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMiLCJoYW5kbGVTb2NrZXRFcnJvciIsImhhbmRsZVNvY2tldEVuZCIsImhhbmRsZVNvY2tldENsb3NlIiwiaGFuZGxlU29ja2V0RHJhaW4iLCJoYW5kbGVTb2NrZXRQYXVzZSIsImhhbmRsZVNvY2tldFJlc3VtZSIsImhhbmRsZVNvY2tldERhdGEiLCJjbGVhcktlZXBhbGl2ZVRpbWVyIiwiY2xlYXJHcmFjZVBlcmlvZFRpbWVyIiwiX2tlZXBhbGl2ZVRpbWVvdXRJRCIsImNsZWFyVGltZW91dCIsInBpbmciLCJzZXRHcmFjZVBlcmlvZFRpbWVyIiwiX2dyYWNlUGVyaW9kVGltZW91dElEIiwiZHJvcCIsImRhdGEiLCJ3cml0ZSIsImZyYW1lIiwiYWRkRGF0YSIsInNlbGYiLCJwcm90b2NvbEVycm9yIiwiZHJvcFJlYXNvbiIsImZyYW1lVG9vTGFyZ2UiLCJyc3YxIiwicnN2MiIsInJzdjMiLCJlbWl0IiwicHJvY2Vzc0ZyYW1lIiwibGVuZ3RoIiwiZXJyb3IiLCJzeXNjYWxsIiwiZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCIsImRlc3Ryb3kiLCJwcmludE91dHB1dCIsImVuZCIsImhhZEVycm9yIiwic29ja2V0SGFkRXJyb3IiLCJjbGVhckNsb3NlVGltZXIiLCJwYXVzZSIsInJlc3VtZSIsImNsb3NlIiwicmVhc29uQ29kZSIsImRlc2NyaXB0aW9uIiwic2V0Q2xvc2VUaW1lciIsInNlbmRDbG9zZUZyYW1lIiwic2tpcENsb3NlRnJhbWUiLCJjbG9zZVRpbWVyIiwib3Bjb2RlIiwidG9TdHJpbmciLCJmaW4iLCJ0eXBlIiwiYmluYXJ5RGF0YSIsImJpbmFyeVBheWxvYWQiLCJwdXNoIiwidXRmOERhdGEiLCJieXRlc0NvcGllZCIsImZvckVhY2giLCJjb3B5IiwiY2FuY2VsbGVkIiwiY2FuY2VsIiwicG9uZyIsInJlc3BvbmRDbG9zZVJlYXNvbkNvZGUiLCJpbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCIsImNsb3NlU3RhdHVzIiwic2VuZCIsImNiIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJzZW5kQnl0ZXMiLCJzZW5kVVRGIiwiZnJhZ21lbnRBbmRTZW5kIiwic2xpY2UiLCJzZW5kRnJhbWUiLCJ0aHJlc2hvbGQiLCJmcmFnbWVudGF0aW9uVGhyZXNob2xkIiwiZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzIiwibnVtRnJhZ21lbnRzIiwiTWF0aCIsImNlaWwiLCJzZW50RnJhZ21lbnRzIiwic2VudENhbGxiYWNrIiwiZnJhZ21lbnRTZW50Q2FsbGJhY2siLCJlcnIiLCJpIiwiY3VycmVudExlbmd0aCIsInNsaWNlU3RhcnQiLCJtYXNrIiwiZmx1c2hlZCIsInRvQnVmZmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbm5lY3Rpb24iLCJvcmlnaW5hbFNvY2tldEVtaXQiLCJldmVudCIsImFwcGx5IiwiYXJndW1lbnRzIiwia2V5Iiwib3JpZ2luYWwiLCJwcm94eU1ldGhvZF9fRXZlbnRFbWl0dGVyX19PbiIsInByb3h5TWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketFrame.js":
/*!******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketFrame.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar bufferUtil = __webpack_require__(/*! bufferutil */ \"(rsc)/./node_modules/bufferutil/index.js\");\nvar bufferAllocUnsafe = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n            this.fin = Boolean(firstByte & 0x80);\n            this.rsv1 = Boolean(firstByte & 0x40);\n            this.rsv2 = Boolean(firstByte & 0x20);\n            this.rsv3 = Boolean(firstByte & 0x10);\n            this.mask = Boolean(secondByte & 0x80);\n            this.opcode = firstByte & 0x0F;\n            this.length = secondByte & 0x7F;\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = \"Illegal control frame longer than 125 bytes.\";\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = \"Control frames must not be fragmented.\";\n                    return true;\n                }\n            }\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            } else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            } else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n                this.frameHeader.readUInt32BE(2),\n                this.frameHeader.readUInt32BE(2 + 4)\n            ];\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = \"Unsupported 64-bit length frame received\";\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        } else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = \"Frame size of \" + this.length.toString(10) + \" bytes exceeds maximum accepted frame size\";\n            return true;\n        }\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n            // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n            if (this.opcode === 0x08) {\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n    firstByte |= this.opcode & 0x0F;\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    } else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    } else {\n        this.length = 0;\n    }\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= this.length & 0x7F;\n    } else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    } else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n    outputPos = 2;\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    } else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n    if (this.mask) {\n        maskKey = nullMask ? 0 : Math.random() * 0xFFFFFFFF >>> 0;\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n        if (data) {\n            bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    } else if (data) {\n        data.copy(output, outputPos);\n    }\n    return output;\n};\nWebSocketFrame.prototype.toString = function() {\n    return \"Opcode: \" + this.opcode + \", fin: \" + this.fin + \", length: \" + this.length + \", hasPayload: \" + Boolean(this.binaryPayload) + \", masked: \" + this.mask;\n};\nmodule.exports = WebSocketFrame;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFO0FBRXZFLElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLG9CQUFvQkQscUdBQW9DO0FBRTVELE1BQU1FLGdCQUFnQjtBQUN0QixNQUFNQyw0QkFBNEI7QUFDbEMsTUFBTUMsNEJBQTRCO0FBQ2xDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsV0FBVztBQUVqQix3RUFBd0U7QUFDeEUsNkVBQTZFO0FBQzdFLHlFQUF5RTtBQUN6RSwyQkFBMkI7QUFDM0IsU0FBU0MsZUFBZUMsU0FBUyxFQUFFQyxXQUFXLEVBQUVDLE1BQU07SUFDbEQsSUFBSSxDQUFDRixTQUFTLEdBQUdBO0lBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7SUFDZCxJQUFJLENBQUNDLG9CQUFvQixHQUFHRCxPQUFPQyxvQkFBb0I7SUFDdkQsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRztJQUMvQixJQUFJLENBQUNDLFVBQVUsR0FBR2Q7SUFDbEIsSUFBSSxDQUFDZSxXQUFXLEdBQUcsQ0FBQztBQUN4QjtBQUVBVCxlQUFlVSxTQUFTLENBQUNDLE9BQU8sR0FBRyxTQUFTQyxVQUFVO0lBQ2xELElBQUksSUFBSSxDQUFDSixVQUFVLEtBQUtkLGVBQWU7UUFDbkMsSUFBSWtCLFdBQVdDLE1BQU0sSUFBSSxHQUFHO1lBQ3hCRCxXQUFXRSxRQUFRLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUUsR0FBRyxHQUFHO1lBQzVDVSxXQUFXRyxPQUFPLENBQUM7WUFDbkIsSUFBSUMsWUFBWSxJQUFJLENBQUNkLFdBQVcsQ0FBQyxFQUFFO1lBQ25DLElBQUll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T0FBT0MsYUFBYSxDQUFDLElBQUksQ0FBQy9CLE1BQU0sRUFBRTJCLFlBQVk7UUFDOUNBLGFBQWE7SUFDakI7SUFFQSxJQUFJLElBQUksQ0FBQ2pCLElBQUksRUFBRTtRQUNYYyxVQUFVRCxXQUFXLElBQUssS0FBTVUsTUFBTSxLQUFLLGVBQWdCO1FBQzNELElBQUksQ0FBQzdDLFNBQVMsQ0FBQzJDLGFBQWEsQ0FBQ1AsU0FBUztRQUV0QyxxQkFBcUI7UUFDckIsSUFBSSxDQUFDcEMsU0FBUyxDQUFDeUMsSUFBSSxDQUFDQyxRQUFRSDtRQUM1QkEsYUFBYTtRQUViLElBQUlELE1BQU07WUFDUmhELFdBQVdnQyxJQUFJLENBQUNnQixNQUFNLElBQUksQ0FBQ3RDLFNBQVMsRUFBRTBDLFFBQVFILFdBQVcsSUFBSSxDQUFDM0IsTUFBTTtRQUN0RTtJQUNKLE9BQ0ssSUFBSTBCLE1BQU07UUFDWEEsS0FBS0csSUFBSSxDQUFDQyxRQUFRSDtJQUN0QjtJQUVBLE9BQU9HO0FBQ1g7QUFFQTNDLGVBQWVVLFNBQVMsQ0FBQ21CLFFBQVEsR0FBRztJQUNoQyxPQUFPLGFBQWEsSUFBSSxDQUFDTCxNQUFNLEdBQUcsWUFBWSxJQUFJLENBQUNOLEdBQUcsR0FBRyxlQUFlLElBQUksQ0FBQ0wsTUFBTSxHQUFHLG1CQUFtQk0sUUFBUSxJQUFJLENBQUNXLGFBQWEsSUFBSSxlQUFlLElBQUksQ0FBQ1AsSUFBSTtBQUNuSztBQUdBd0IsT0FBT0MsT0FBTyxHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcz9jNmYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSByZXF1aXJlKCcuL3V0aWxzJykuYnVmZmVyQWxsb2NVbnNhZmU7XG5cbmNvbnN0IERFQ09ERV9IRUFERVIgPSAxO1xuY29uc3QgV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCA9IDI7XG5jb25zdCBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIID0gMztcbmNvbnN0IFdBSVRJTkdfRk9SX01BU0tfS0VZID0gNDtcbmNvbnN0IFdBSVRJTkdfRk9SX1BBWUxPQUQgPSA1O1xuY29uc3QgQ09NUExFVEUgPSA2O1xuXG4vLyBXZWJTb2NrZXRDb25uZWN0aW9uIHdpbGwgcGFzcyBzaGFyZWQgYnVmZmVyIG9iamVjdHMgZm9yIG1hc2tCeXRlcyBhbmRcbi8vIGZyYW1lSGVhZGVyIGludG8gdGhlIGNvbnN0cnVjdG9yIHRvIGF2b2lkIHRvbnMgb2Ygc21hbGwgbWVtb3J5IGFsbG9jYXRpb25zXG4vLyBmb3IgZWFjaCBmcmFtZSB3ZSBoYXZlIHRvIHBhcnNlLiAgVGhpcyBpcyBvbmx5IHVzZWQgZm9yIHBhcnNpbmcgZnJhbWVzXG4vLyB3ZSByZWNlaXZlIG9mZiB0aGUgd2lyZS5cbmZ1bmN0aW9uIFdlYlNvY2tldEZyYW1lKG1hc2tCeXRlcywgZnJhbWVIZWFkZXIsIGNvbmZpZykge1xuICAgIHRoaXMubWFza0J5dGVzID0gbWFza0J5dGVzO1xuICAgIHRoaXMuZnJhbWVIZWFkZXIgPSBmcmFtZUhlYWRlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1heFJlY2VpdmVkRnJhbWVTaXplID0gY29uZmlnLm1heFJlY2VpdmVkRnJhbWVTaXplO1xuICAgIHRoaXMucHJvdG9jb2xFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVUb29MYXJnZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52YWxpZENsb3NlRnJhbWVMZW5ndGggPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlU3RhdGUgPSBERUNPREVfSEVBREVSO1xuICAgIHRoaXMuY2xvc2VTdGF0dXMgPSAtMTtcbn1cblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbihidWZmZXJMaXN0KSB7XG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gREVDT0RFX0hFQURFUikge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAwLCAwLCAyKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSgyKTtcbiAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSB0aGlzLmZyYW1lSGVhZGVyWzBdO1xuICAgICAgICAgICAgdmFyIHNlY29uZEJ5dGUgPSB0aGlzLmZyYW1lSGVhZGVyWzFdO1xuXG4gICAgICAgICAgICB0aGlzLmZpbiAgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDgwKTtcbiAgICAgICAgICAgIHRoaXMucnN2MSAgICA9IEJvb2xlYW4oZmlyc3RCeXRlICAmIDB4NDApO1xuICAgICAgICAgICAgdGhpcy5yc3YyICAgID0gQm9vbGVhbihmaXJzdEJ5dGUgICYgMHgyMCk7XG4gICAgICAgICAgICB0aGlzLnJzdjMgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDEwKTtcbiAgICAgICAgICAgIHRoaXMubWFzayAgICA9IEJvb2xlYW4oc2Vjb25kQnl0ZSAmIDB4ODApO1xuXG4gICAgICAgICAgICB0aGlzLm9wY29kZSAgPSBmaXJzdEJ5dGUgICYgMHgwRjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gc2Vjb25kQnl0ZSAmIDB4N0Y7XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2wgZnJhbWUgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgICBpZiAodGhpcy5vcGNvZGUgPj0gMHgwOCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEyNSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnSWxsZWdhbCBjb250cm9sIGZyYW1lIGxvbmdlciB0aGFuIDEyNSBieXRlcy4nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnQ29udHJvbCBmcmFtZXMgbXVzdCBub3QgYmUgZnJhZ21lbnRlZC4nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAxMjcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfTUFTS19LRVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCkge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAyLCAwLCAyKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSgyKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDE2QkUoMik7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3Quam9pbkludG8odGhpcy5mcmFtZUhlYWRlciwgMiwgMCwgOCk7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UoOCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoUGFpciA9IFtcbiAgICAgICAgICAgICAgdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDMyQkUoMiksXG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVIZWFkZXIucmVhZFVJbnQzMkJFKDIrNClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGhQYWlyWzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnVW5zdXBwb3J0ZWQgNjQtYml0IGxlbmd0aCBmcmFtZSByZWNlaXZlZCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFBhaXJbMV07XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SX01BU0tfS0VZKSB7XG4gICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLm1hc2tCeXRlcywgMCwgMCwgNCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKDQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX1BBWUxPQUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9QQVlMT0FEO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfUEFZTE9BRCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLm1heFJlY2VpdmVkRnJhbWVTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lVG9vTGFyZ2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcm9wUmVhc29uID0gJ0ZyYW1lIHNpemUgb2YgJyArIHRoaXMubGVuZ3RoLnRvU3RyaW5nKDEwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzIGV4Y2VlZHMgbWF4aW11bSBhY2NlcHRlZCBmcmFtZSBzaXplJztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJMaXN0LnRha2UodGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICAgICAgICBidWZmZXJVdGlsLnVubWFzayh0aGlzLmJpbmFyeVBheWxvYWQsIHRoaXMubWFza0J5dGVzKTtcbiAgICAgICAgICAgICAgICAvLyB4b3IodGhpcy5iaW5hcnlQYXlsb2FkLCB0aGlzLm1hc2tCeXRlcywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wY29kZSA9PT0gMHgwOCkgeyAvLyBXZWJTb2NrZXRPcGNvZGUuQ09OTkVDVElPTl9DTE9TRVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxlbmd0aCBmb3IgYSBjbG9zZSBmcmFtZS4gIE11c3QgYmUgemVybyBvciBhdCBsZWFzdCB0d28uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRDbG9zZUZyYW1lTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN0YXR1cyA9IHRoaXMuYmluYXJ5UGF5bG9hZC5yZWFkVUludDE2QkUoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IHRoaXMuYmluYXJ5UGF5bG9hZC5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRocm93QXdheVBheWxvYWQgPSBmdW5jdGlvbihidWZmZXJMaXN0KSB7XG4gICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24obnVsbE1hc2spIHtcbiAgICB2YXIgbWFza0tleTtcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gMjtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3V0cHV0UG9zO1xuICAgIHZhciBmaXJzdEJ5dGUgPSAweDAwO1xuICAgIHZhciBzZWNvbmRCeXRlID0gMHgwMDtcblxuICAgIGlmICh0aGlzLmZpbikge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHg4MDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2MSkge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHg0MDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2Mikge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHgyMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2Mykge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHgxMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICBzZWNvbmRCeXRlIHw9IDB4ODA7XG4gICAgfVxuXG4gICAgZmlyc3RCeXRlIHw9ICh0aGlzLm9wY29kZSAmIDB4MEYpO1xuXG4gICAgLy8gdGhlIGNsb3NlIGZyYW1lIGlzIGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgdGhlIGNsb3NlIHJlYXNvbiBpc1xuICAgIC8vIHByZXBlbmRlZCB0byB0aGUgcGF5bG9hZCBkYXRhLlxuICAgIGlmICh0aGlzLm9wY29kZSA9PT0gMHgwOCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRoaXMuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZGF0YS53cml0ZVVJbnQxNkJFKHRoaXMuY2xvc2VTdGF0dXMsIDApO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQuY29weShkYXRhLCAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVBheWxvYWQpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuYmluYXJ5UGF5bG9hZDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gMTI1KSB7XG4gICAgICAgIC8vIGVuY29kZSB0aGUgbGVuZ3RoIGRpcmVjdGx5IGludG8gdGhlIHR3by1ieXRlIGZyYW1lIGhlYWRlclxuICAgICAgICBzZWNvbmRCeXRlIHw9ICh0aGlzLmxlbmd0aCAmIDB4N0YpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDEyNSAmJiB0aGlzLmxlbmd0aCA8PSAweEZGRkYpIHtcbiAgICAgICAgLy8gVXNlIDE2LWJpdCBsZW5ndGhcbiAgICAgICAgc2Vjb25kQnl0ZSB8PSAxMjY7XG4gICAgICAgIGhlYWRlckxlbmd0aCArPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDB4RkZGRikge1xuICAgICAgICAvLyBVc2UgNjQtYml0IGxlbmd0aFxuICAgICAgICBzZWNvbmRCeXRlIHw9IDEyNztcbiAgICAgICAgaGVhZGVyTGVuZ3RoICs9IDg7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoICsgaGVhZGVyTGVuZ3RoICsgKHRoaXMubWFzayA/IDQgOiAwKSk7XG5cbiAgICAvLyB3cml0ZSB0aGUgZnJhbWUgaGVhZGVyXG4gICAgb3V0cHV0WzBdID0gZmlyc3RCeXRlO1xuICAgIG91dHB1dFsxXSA9IHNlY29uZEJ5dGU7XG5cbiAgICBvdXRwdXRQb3MgPSAyO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMTI1ICYmIHRoaXMubGVuZ3RoIDw9IDB4RkZGRikge1xuICAgICAgICAvLyB3cml0ZSAxNi1iaXQgbGVuZ3RoXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQxNkJFKHRoaXMubGVuZ3RoLCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXRQb3MgKz0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPiAweEZGRkYpIHtcbiAgICAgICAgLy8gd3JpdGUgNjQtYml0IGxlbmd0aFxuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRSgweDAwMDAwMDAwLCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRSh0aGlzLmxlbmd0aCwgb3V0cHV0UG9zICsgNCk7XG4gICAgICAgIG91dHB1dFBvcyArPSA4O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgbWFza0tleSA9IG51bGxNYXNrID8gMCA6ICgoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpID4+PiAwKTtcbiAgICAgICAgdGhpcy5tYXNrQnl0ZXMud3JpdGVVSW50MzJCRShtYXNrS2V5LCAwKTtcblxuICAgICAgICAvLyB3cml0ZSB0aGUgbWFzayBrZXlcbiAgICAgICAgdGhpcy5tYXNrQnl0ZXMuY29weShvdXRwdXQsIG91dHB1dFBvcyk7XG4gICAgICAgIG91dHB1dFBvcyArPSA0O1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgYnVmZmVyVXRpbC5tYXNrKGRhdGEsIHRoaXMubWFza0J5dGVzLCBvdXRwdXQsIG91dHB1dFBvcywgdGhpcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5jb3B5KG91dHB1dCwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdPcGNvZGU6ICcgKyB0aGlzLm9wY29kZSArICcsIGZpbjogJyArIHRoaXMuZmluICsgJywgbGVuZ3RoOiAnICsgdGhpcy5sZW5ndGggKyAnLCBoYXNQYXlsb2FkOiAnICsgQm9vbGVhbih0aGlzLmJpbmFyeVBheWxvYWQpICsgJywgbWFza2VkOiAnICsgdGhpcy5tYXNrO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldEZyYW1lO1xuIl0sIm5hbWVzIjpbImJ1ZmZlclV0aWwiLCJyZXF1aXJlIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJERUNPREVfSEVBREVSIiwiV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCIsIldBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEgiLCJXQUlUSU5HX0ZPUl9NQVNLX0tFWSIsIldBSVRJTkdfRk9SX1BBWUxPQUQiLCJDT01QTEVURSIsIldlYlNvY2tldEZyYW1lIiwibWFza0J5dGVzIiwiZnJhbWVIZWFkZXIiLCJjb25maWciLCJtYXhSZWNlaXZlZEZyYW1lU2l6ZSIsInByb3RvY29sRXJyb3IiLCJmcmFtZVRvb0xhcmdlIiwiaW52YWxpZENsb3NlRnJhbWVMZW5ndGgiLCJwYXJzZVN0YXRlIiwiY2xvc2VTdGF0dXMiLCJwcm90b3R5cGUiLCJhZGREYXRhIiwiYnVmZmVyTGlzdCIsImxlbmd0aCIsImpvaW5JbnRvIiwiYWR2YW5jZSIsImZpcnN0Qnl0ZSIsInNlY29uZEJ5dGUiLCJmaW4iLCJCb29sZWFuIiwicnN2MSIsInJzdjIiLCJyc3YzIiwibWFzayIsIm9wY29kZSIsImRyb3BSZWFzb24iLCJyZWFkVUludDE2QkUiLCJsZW5ndGhQYWlyIiwicmVhZFVJbnQzMkJFIiwidG9TdHJpbmciLCJiaW5hcnlQYXlsb2FkIiwidGFrZSIsInVubWFzayIsInNsaWNlIiwidGhyb3dBd2F5UGF5bG9hZCIsInRvQnVmZmVyIiwibnVsbE1hc2siLCJtYXNrS2V5IiwiaGVhZGVyTGVuZ3RoIiwiZGF0YSIsIm91dHB1dFBvcyIsIndyaXRlVUludDE2QkUiLCJjb3B5Iiwib3V0cHV0Iiwid3JpdGVVSW50MzJCRSIsIk1hdGgiLCJyYW5kb20iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketFrame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar controlChars = [\n    String.fromCharCode(127)\n];\nfor(var i = 0; i < 31; i++){\n    /* US-ASCII Control Characters */ controlChars.push(String.fromCharCode(i));\n}\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\nvar cookieSeparatorRegEx = /[;,] */;\nvar httpStatusDescriptions = {\n    100: \"Continue\",\n    101: \"Switching Protocols\",\n    200: \"OK\",\n    201: \"Created\",\n    203: \"Non-Authoritative Information\",\n    204: \"No Content\",\n    205: \"Reset Content\",\n    206: \"Partial Content\",\n    300: \"Multiple Choices\",\n    301: \"Moved Permanently\",\n    302: \"Found\",\n    303: \"See Other\",\n    304: \"Not Modified\",\n    305: \"Use Proxy\",\n    307: \"Temporary Redirect\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authorization Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Long\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    426: \"Upgrade Required\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\"\n};\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [\n        this.remoteAddress\n    ];\n    this.serverConfig = serverConfig;\n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on(\"end\", this._socketCloseHandler);\n    this.socket.on(\"close\", this._socketCloseHandler);\n    this._resolved = false;\n}\nutil.inherits(WebSocketRequest, EventEmitter);\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n    this.host = request.headers[\"host\"];\n    if (!this.host) {\n        throw new Error(\"Client must provide a Host header.\");\n    }\n    this.key = request.headers[\"sec-websocket-key\"];\n    if (!this.key) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Key.\");\n    }\n    this.webSocketVersion = parseInt(request.headers[\"sec-websocket-version\"], 10);\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Version.\");\n    }\n    switch(this.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error(\"Unsupported websocket client version: \" + this.webSocketVersion + \"Only versions 8 and 13 are supported.\");\n            e.httpCode = 426;\n            e.headers = {\n                \"Sec-WebSocket-Version\": \"13\"\n            };\n            throw e;\n    }\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers[\"origin\"];\n    } else if (this.webSocketVersion === 8) {\n        this.origin = request.headers[\"sec-websocket-origin\"];\n    }\n    // Protocol is optional.\n    var protocolString = request.headers[\"sec-websocket-protocol\"];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n    if (!this.serverConfig.ignoreXForwardedFor && request.headers[\"x-forwarded-for\"]) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers[\"x-forwarded-for\"].split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n    // Extensions are optional.\n    if (this.serverConfig.parseExtensions) {\n        var extensionsString = request.headers[\"sec-websocket-extensions\"];\n        this.requestedExtensions = this.parseExtensions(extensionsString);\n    } else {\n        this.requestedExtensions = [];\n    }\n    // Cookies are optional\n    if (this.serverConfig.parseCookies) {\n        var cookieString = request.headers[\"cookie\"];\n        this.cookies = this.parseCookies(cookieString);\n    } else {\n        this.cookies = [];\n    }\n};\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split(\"=\");\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof str !== \"string\") {\n        return [];\n    }\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf(\"=\");\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n    return cookies;\n};\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n    // TODO: Handle extensions\n    var protocolFullCase;\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof protocolFullCase === \"undefined\") {\n            protocolFullCase = acceptedProtocol;\n        }\n    } else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n    // Create key validation hash\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var acceptKey = sha1.digest(\"base64\");\n    var response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" + \"Upgrade: websocket\\r\\n\" + \"Connection: Upgrade\\r\\n\" + \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\";\n    if (protocolFullCase) {\n        // validate protocol\n        for(var i = 0; i < protocolFullCase.length; i++){\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error(\"Specified protocol was not requested by the client.\");\n        }\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, \"\");\n        response += \"Sec-WebSocket-Protocol: \" + protocolFullCase + \"\\r\\n\";\n    }\n    this.requestedProtocols = null;\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, \"\");\n        if (this.webSocketVersion === 13) {\n            response += \"Origin: \" + allowedOrigin + \"\\r\\n\";\n        } else if (this.webSocketVersion === 8) {\n            response += \"Sec-WebSocket-Origin: \" + allowedOrigin + \"\\r\\n\";\n        }\n    }\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach((function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, \"\");\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, \"\");\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error(\"You may not specify the same cookie name twice.\");\n            }\n            seenCookies[cookie.name] = true;\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie name\");\n            }\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie value\");\n            }\n            var cookieParts = [\n                cookie.name + \"=\" + cookie.value\n            ];\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if (cookie.path) {\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie path\");\n                }\n                cookieParts.push(\"Path=\" + cookie.path);\n            }\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof cookie.domain !== \"string\") {\n                    this.reject(500);\n                    throw new Error(\"Domain must be specified and must be a string.\");\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie domain\");\n                }\n                cookieParts.push(\"Domain=\" + cookie.domain.toLowerCase());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push(\"Expires=\" + cookie.expires.toGMTString());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof maxage === \"string\") {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push(\"Max-Age=\" + maxage.toString(10));\n            }\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof cookie.secure !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push(\"Secure\");\n            }\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof cookie.httponly !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push(\"HttpOnly\");\n            }\n            response += \"Set-Cookie: \" + cookieParts.join(\";\") + \"\\r\\n\";\n        }).bind(this));\n    }\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    response += \"\\r\\n\";\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n    var self = this;\n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    } else {\n        this.socket.write(response, \"ascii\", function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    if (typeof status !== \"number\") {\n        status = 403;\n    }\n    var response = \"HTTP/1.1 \" + status + \" \" + httpStatusDescriptions[status] + \"\\r\\n\" + \"Connection: close\\r\\n\";\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, \"\");\n        response += \"X-WebSocket-Reject-Reason: \" + reason + \"\\r\\n\";\n    }\n    if (extraHeaders) {\n        for(var key in extraHeaders){\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, \"\");\n            var sanitizedKey = key.replace(headerSanitizeRegExp, \"\");\n            response += sanitizedKey + \": \" + sanitizedValue + \"\\r\\n\";\n        }\n    }\n    response += \"\\r\\n\";\n    this.socket.end(response, \"ascii\");\n    this.emit(\"requestRejected\", this);\n};\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener(\"end\", this._socketCloseHandler);\n    this.socket.removeListener(\"close\", this._socketCloseHandler);\n};\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error(\"WebSocketRequest may only be accepted or rejected one time.\");\n    }\n};\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, \"TCP connection lost before handshake completed.\", true);\n    });\n}\nmodule.exports = WebSocketRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsTUFBTUYsbUJBQU9BLENBQUM7QUFDbEIsSUFBSUcsZUFBZUgsMERBQThCO0FBQ2pELElBQUlJLHNCQUFzQkosbUJBQU9BLENBQUM7QUFFbEMsSUFBSUsseUJBQXlCO0FBQzdCLElBQUlDLHlCQUF5QjtBQUM3QixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsK0JBQStCO0FBQ25DLElBQUlDLGFBQWE7SUFDYjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLO0lBQU07SUFDckI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBS0MsT0FBT0MsWUFBWSxDQUFDO0NBQ3RDO0FBQ0QsSUFBSUMsZUFBZTtJQUFDRixPQUFPQyxZQUFZLENBQUM7Q0FBZTtBQUN2RCxJQUFLLElBQUlFLElBQUUsR0FBR0EsSUFBSSxJQUFJQSxJQUFNO0lBQ3hCLCtCQUErQixHQUMvQkQsYUFBYUUsSUFBSSxDQUFDSixPQUFPQyxZQUFZLENBQUNFO0FBQzFDO0FBRUEsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUMvQixJQUFJQyxpQ0FBaUM7QUFDckMsSUFBSUMsZ0NBQWdDO0FBRXBDLElBQUlDLHVCQUF1QjtBQUUzQixJQUFJQyx5QkFBeUI7SUFDekIsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNM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QUNwRSx1REFBdUQ7SUFDdkRhLFFBQVFDLFFBQVEsQ0FBQztRQUNiLG1EQUFtRDtRQUNuRCw2REFBNkQ7UUFDN0RkLFdBQVdlLElBQUksQ0FBQyxNQUFNLG1EQUFtRDtJQUM3RTtBQUNKO0FBRUFDLE9BQU9DLE9BQU8sR0FBRy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0UmVxdWVzdC5qcz8yYmU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL1dlYlNvY2tldENvbm5lY3Rpb24nKTtcblxudmFyIGhlYWRlclZhbHVlU3BsaXRSZWdFeHAgPSAvLFxccyovO1xudmFyIGhlYWRlclBhcmFtU3BsaXRSZWdFeHAgPSAvO1xccyovO1xudmFyIGhlYWRlclNhbml0aXplUmVnRXhwID0gL1tcXHJcXG5dL2c7XG52YXIgeEZvcndhcmRlZEZvclNlcGFyYXRvclJlZ0V4cCA9IC8sXFxzKi87XG52YXIgc2VwYXJhdG9ycyA9IFtcbiAgICAnKCcsICcpJywgJzwnLCAnPicsICdAJyxcbiAgICAnLCcsICc7JywgJzonLCAnXFxcXCcsICdcXFwiJyxcbiAgICAnLycsICdbJywgJ10nLCAnPycsICc9JyxcbiAgICAneycsICd9JywgJyAnLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpXG5dO1xudmFyIGNvbnRyb2xDaGFycyA9IFtTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNykgLyogREVMICovXTtcbmZvciAodmFyIGk9MDsgaSA8IDMxOyBpICsrKSB7XG4gICAgLyogVVMtQVNDSUkgQ29udHJvbCBDaGFyYWN0ZXJzICovXG4gICAgY29udHJvbENoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG59XG5cbnZhciBjb29raWVOYW1lVmFsaWRhdGVSZWdFeCA9IC8oW1xceDAwLVxceDIwXFx4MjJcXHgyOFxceDI5XFx4MmNcXHgyZlxceDNhLVxceDNmXFx4NDBcXHg1Yi1cXHg1ZVxceDdiXFx4N2RcXHg3Zl0pLztcbnZhciBjb29raWVWYWx1ZVZhbGlkYXRlUmVnRXggPSAvW15cXHgyMVxceDIzLVxceDJiXFx4MmQtXFx4M2FcXHgzYy1cXHg1YlxceDVkLVxceDdlXS87XG52YXIgY29va2llVmFsdWVEUXVvdGVWYWxpZGF0ZVJlZ0V4ID0gL15cIlteXCJdKlwiJC87XG52YXIgY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXggPSAvW1xceDAwLVxceDIwXFx4M2JdL2c7XG5cbnZhciBjb29raWVTZXBhcmF0b3JSZWdFeCA9IC9bOyxdICovO1xuXG52YXIgaHR0cFN0YXR1c0Rlc2NyaXB0aW9ucyA9IHtcbiAgICAxMDA6ICdDb250aW51ZScsXG4gICAgMTAxOiAnU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgMjAwOiAnT0snLFxuICAgIDIwMTogJ0NyZWF0ZWQnLFxuICAgIDIwMzogJ05vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uJyxcbiAgICAyMDQ6ICdObyBDb250ZW50JyxcbiAgICAyMDU6ICdSZXNldCBDb250ZW50JyxcbiAgICAyMDY6ICdQYXJ0aWFsIENvbnRlbnQnLFxuICAgIDMwMDogJ011bHRpcGxlIENob2ljZXMnLFxuICAgIDMwMTogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDI6ICdGb3VuZCcsXG4gICAgMzAzOiAnU2VlIE90aGVyJyxcbiAgICAzMDQ6ICdOb3QgTW9kaWZpZWQnLFxuICAgIDMwNTogJ1VzZSBQcm94eScsXG4gICAgMzA3OiAnVGVtcG9yYXJ5IFJlZGlyZWN0JyxcbiAgICA0MDA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxOiAnVW5hdXRob3JpemVkJyxcbiAgICA0MDI6ICdQYXltZW50IFJlcXVpcmVkJyxcbiAgICA0MDM6ICdGb3JiaWRkZW4nLFxuICAgIDQwNDogJ05vdCBGb3VuZCcsXG4gICAgNDA2OiAnTm90IEFjY2VwdGFibGUnLFxuICAgIDQwNzogJ1Byb3h5IEF1dGhvcml6YXRpb24gUmVxdWlyZWQnLFxuICAgIDQwODogJ1JlcXVlc3QgVGltZW91dCcsXG4gICAgNDA5OiAnQ29uZmxpY3QnLFxuICAgIDQxMDogJ0dvbmUnLFxuICAgIDQxMTogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gICAgNDEyOiAnUHJlY29uZGl0aW9uIEZhaWxlZCcsXG4gICAgNDEzOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExvbmcnLFxuICAgIDQxNDogJ1JlcXVlc3QtVVJJIFRvbyBMb25nJyxcbiAgICA0MTU6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTY6ICdSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlJyxcbiAgICA0MTc6ICdFeHBlY3RhdGlvbiBGYWlsZWQnLFxuICAgIDQyNjogJ1VwZ3JhZGUgUmVxdWlyZWQnLFxuICAgIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgNTAxOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDI6ICdCYWQgR2F0ZXdheScsXG4gICAgNTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgNTA0OiAnR2F0ZXdheSBUaW1lb3V0JyxcbiAgICA1MDU6ICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCdcbn07XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFJlcXVlc3Qoc29ja2V0LCBodHRwUmVxdWVzdCwgc2VydmVyQ29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICAgIHRoaXMucmVzb3VyY2UgPSBodHRwUmVxdWVzdC51cmw7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzZXMgPSBbdGhpcy5yZW1vdGVBZGRyZXNzXTtcbiAgICB0aGlzLnNlcnZlckNvbmZpZyA9IHNlcnZlckNvbmZpZztcblxuICAgIC8vIFdhdGNoIGZvciB0aGUgdW5kZXJseWluZyBUQ1Agc29ja2V0IGNsb3NpbmcgYmVmb3JlIHdlIGNhbGwgYWNjZXB0XG4gICAgdGhpcy5fc29ja2V0SXNDbG9zaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyID0gdGhpcy5faGFuZGxlU29ja2V0Q2xvc2VCZWZvcmVBY2NlcHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcbiAgICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xuXG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRSZXF1ZXN0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5yZWFkSGFuZHNoYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5odHRwUmVxdWVzdDtcblxuICAgIC8vIERlY29kZSBVUkxcbiAgICB0aGlzLnJlc291cmNlVVJMID0gdXJsLnBhcnNlKHRoaXMucmVzb3VyY2UsIHRydWUpO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVxdWVzdC5oZWFkZXJzWydob3N0J107XG4gICAgaWYgKCF0aGlzLmhvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbXVzdCBwcm92aWRlIGEgSG9zdCBoZWFkZXIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J107XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBtdXN0IHByb3ZpZGUgYSB2YWx1ZSBmb3IgU2VjLVdlYlNvY2tldC1LZXkuJyk7XG4gICAgfVxuXG4gICAgdGhpcy53ZWJTb2NrZXRWZXJzaW9uID0gcGFyc2VJbnQocmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXSwgMTApO1xuXG4gICAgaWYgKCF0aGlzLndlYlNvY2tldFZlcnNpb24gfHwgaXNOYU4odGhpcy53ZWJTb2NrZXRWZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBtdXN0IHByb3ZpZGUgYSB2YWx1ZSBmb3IgU2VjLVdlYlNvY2tldC1WZXJzaW9uLicpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy53ZWJTb2NrZXRWZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHdlYnNvY2tldCBjbGllbnQgdmVyc2lvbjogJyArIHRoaXMud2ViU29ja2V0VmVyc2lvbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnT25seSB2ZXJzaW9ucyA4IGFuZCAxMyBhcmUgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZS5odHRwQ29kZSA9IDQyNjtcbiAgICAgICAgICAgIGUuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogJzEzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSByZXF1ZXN0LmhlYWRlcnNbJ29yaWdpbiddO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJ107XG4gICAgfVxuXG4gICAgLy8gUHJvdG9jb2wgaXMgb3B0aW9uYWwuXG4gICAgdmFyIHByb3RvY29sU3RyaW5nID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgdGhpcy5wcm90b2NvbEZ1bGxDYXNlTWFwID0ge307XG4gICAgdGhpcy5yZXF1ZXN0ZWRQcm90b2NvbHMgPSBbXTtcbiAgICBpZiAocHJvdG9jb2xTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZFByb3RvY29sc0Z1bGxDYXNlID0gcHJvdG9jb2xTdHJpbmcuc3BsaXQoaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCk7XG4gICAgICAgIHJlcXVlc3RlZFByb3RvY29sc0Z1bGxDYXNlLmZvckVhY2goZnVuY3Rpb24ocHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHZhciBsY1Byb3RvY29sID0gcHJvdG9jb2wudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdGVkUHJvdG9jb2xzLnB1c2gobGNQcm90b2NvbCk7XG4gICAgICAgICAgICBzZWxmLnByb3RvY29sRnVsbENhc2VNYXBbbGNQcm90b2NvbF0gPSBwcm90b2NvbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNlcnZlckNvbmZpZy5pZ25vcmVYRm9yd2FyZGVkRm9yICYmXG4gICAgICAgIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ10pIHtcbiAgICAgICAgdmFyIGltbWVkaWF0ZVBlZXJJUCA9IHRoaXMucmVtb3RlQWRkcmVzcztcbiAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzZXMgPSByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddXG4gICAgICAgICAgICAuc3BsaXQoeEZvcndhcmRlZEZvclNlcGFyYXRvclJlZ0V4cCk7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkcmVzc2VzLnB1c2goaW1tZWRpYXRlUGVlcklQKTtcbiAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gdGhpcy5yZW1vdGVBZGRyZXNzZXNbMF07XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9ucyBhcmUgb3B0aW9uYWwuXG4gICAgaWYgKHRoaXMuc2VydmVyQ29uZmlnLnBhcnNlRXh0ZW5zaW9ucykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uc1N0cmluZyA9IHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgICAgIHRoaXMucmVxdWVzdGVkRXh0ZW5zaW9ucyA9IHRoaXMucGFyc2VFeHRlbnNpb25zKGV4dGVuc2lvbnNTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVkRXh0ZW5zaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8vIENvb2tpZXMgYXJlIG9wdGlvbmFsXG4gICAgaWYgKHRoaXMuc2VydmVyQ29uZmlnLnBhcnNlQ29va2llcykge1xuICAgICAgICB2YXIgY29va2llU3RyaW5nID0gcmVxdWVzdC5oZWFkZXJzWydjb29raWUnXTtcbiAgICAgICAgdGhpcy5jb29raWVzID0gdGhpcy5wYXJzZUNvb2tpZXMoY29va2llU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvb2tpZXMgPSBbXTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5wYXJzZUV4dGVuc2lvbnMgPSBmdW5jdGlvbihleHRlbnNpb25zU3RyaW5nKSB7XG4gICAgaWYgKCFleHRlbnNpb25zU3RyaW5nIHx8IGV4dGVuc2lvbnNTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGV4dGVuc2lvbnMgPSBleHRlbnNpb25zU3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCk7XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbiwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBleHRlbnNpb24uc3BsaXQoaGVhZGVyUGFyYW1TcGxpdFJlZ0V4cCk7XG4gICAgICAgIHZhciBleHRlbnNpb25OYW1lID0gcGFyYW1zWzBdO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uUGFyYW1zID0gcGFyYW1zLnNsaWNlKDEpO1xuICAgICAgICBleHRlbnNpb25QYXJhbXMuZm9yRWFjaChmdW5jdGlvbihyYXdQYXJhbSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gcmF3UGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogYXJyWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcnJbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEsIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogZXh0ZW5zaW9uUGFyYW1zXG4gICAgICAgIH07XG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgb2JqKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWRhcHRlZCBmcm9tIG5vZGUtY29va2llXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2h0eWxtYW4vbm9kZS1jb29raWVcbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLnBhcnNlQ29va2llcyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIC8vIFNhbml0eSBDaGVja1xuICAgIGlmICghc3RyIHx8IHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGNvb2tpZXMgPSBbXTtcbiAgICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoY29va2llU2VwYXJhdG9yUmVnRXgpO1xuXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciBlcV9pZHggPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICAgICAgaWYgKGVxX2lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvb2tpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFpcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gcGFpci5zdWJzdHIoMCwgZXFfaWR4KS50cmltKCk7XG4gICAgICAgIHZhciB2YWwgPSBwYWlyLnN1YnN0cigrK2VxX2lkeCwgcGFpci5sZW5ndGgpLnRyaW0oKTtcblxuICAgICAgICAvLyBxdW90ZWQgdmFsdWVzXG4gICAgICAgIGlmICgnXCInID09PSB2YWxbMF0pIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29raWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvb2tpZXM7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbihhY2NlcHRlZFByb3RvY29sLCBhbGxvd2VkT3JpZ2luLCBjb29raWVzKSB7XG4gICAgdGhpcy5fdmVyaWZ5UmVzb2x1dGlvbigpO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIGV4dGVuc2lvbnNcblxuICAgIHZhciBwcm90b2NvbEZ1bGxDYXNlO1xuXG4gICAgaWYgKGFjY2VwdGVkUHJvdG9jb2wpIHtcbiAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IHRoaXMucHJvdG9jb2xGdWxsQ2FzZU1hcFthY2NlcHRlZFByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAodHlwZW9mKHByb3RvY29sRnVsbENhc2UpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IGFjY2VwdGVkUHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByb3RvY29sRnVsbENhc2UgPSBhY2NlcHRlZFByb3RvY29sO1xuICAgIH1cbiAgICB0aGlzLnByb3RvY29sRnVsbENhc2VNYXAgPSBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIGtleSB2YWxpZGF0aW9uIGhhc2hcbiAgICB2YXIgc2hhMSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgc2hhMS51cGRhdGUodGhpcy5rZXkgKyAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyk7XG4gICAgdmFyIGFjY2VwdEtleSA9IHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIHZhciByZXNwb25zZSA9ICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29sc1xcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXRcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbjogVXBncmFkZVxcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdTZWMtV2ViU29ja2V0LUFjY2VwdDogJyArIGFjY2VwdEtleSArICdcXHJcXG4nO1xuXG4gICAgaWYgKHByb3RvY29sRnVsbENhc2UpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgcHJvdG9jb2xcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcHJvdG9jb2xGdWxsQ2FzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcHJvdG9jb2xGdWxsQ2FzZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHByb3RvY29sRnVsbENhc2UuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHgyMSB8fCBjaGFyQ29kZSA+IDB4N0UgfHwgc2VwYXJhdG9ycy5pbmRleE9mKGNoYXJhY3RlcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVyIFwiJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcmFjdGVyKSArICdcIiBpbiBzdWJwcm90b2NvbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0ZWRQcm90b2NvbHMuaW5kZXhPZihhY2NlcHRlZFByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NwZWNpZmllZCBwcm90b2NvbCB3YXMgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG9jb2xGdWxsQ2FzZSA9IHByb3RvY29sRnVsbENhc2UucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICByZXNwb25zZSArPSAnU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJyArIHByb3RvY29sRnVsbENhc2UgKyAnXFxyXFxuJztcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0ZWRQcm90b2NvbHMgPSBudWxsO1xuXG4gICAgaWYgKGFsbG93ZWRPcmlnaW4pIHtcbiAgICAgICAgYWxsb3dlZE9yaWdpbiA9IGFsbG93ZWRPcmlnaW4ucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSAxMykge1xuICAgICAgICAgICAgcmVzcG9uc2UgKz0gJ09yaWdpbjogJyArIGFsbG93ZWRPcmlnaW4gKyAnXFxyXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlICs9ICdTZWMtV2ViU29ja2V0LU9yaWdpbjogJyArIGFsbG93ZWRPcmlnaW4gKyAnXFxyXFxuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb29raWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb29raWVzKSkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIFwiY29va2llc1wiIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZW5Db29raWVzID0ge307XG4gICAgICAgIGNvb2tpZXMuZm9yRWFjaChmdW5jdGlvbihjb29raWUpIHtcbiAgICAgICAgICAgIGlmICghY29va2llLm5hbWUgfHwgIWNvb2tpZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIGNvb2tpZSB0byBzZXQgbXVzdCBhdCBsZWFzdCBwcm92aWRlIGEgXCJuYW1lXCIgYW5kIFwidmFsdWVcIicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIFxcclxcbiBzZXF1ZW5jZXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGNvb2tpZS5uYW1lID0gY29va2llLm5hbWUucmVwbGFjZShjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCwgJycpO1xuICAgICAgICAgICAgY29va2llLnZhbHVlID0gY29va2llLnZhbHVlLnJlcGxhY2UoY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgsICcnKTtcblxuICAgICAgICAgICAgaWYgKHNlZW5Db29raWVzW2Nvb2tpZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBzcGVjaWZ5IHRoZSBzYW1lIGNvb2tpZSBuYW1lIHR3aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlbkNvb2tpZXNbY29va2llLm5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gdG9rZW4gKFJGQyAyNjE2LCBTZWN0aW9uIDIuMilcbiAgICAgICAgICAgIHZhciBpbnZhbGlkQ2hhciA9IGNvb2tpZS5uYW1lLm1hdGNoKGNvb2tpZU5hbWVWYWxpZGF0ZVJlZ0V4KTtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkQ2hhcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSBuYW1lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLyAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKSB8ICV4MjEgLyAleDIzLTJCIC8gJXgyRC0zQSAvICV4M0MtNUIgLyAleDVELTdFXG4gICAgICAgICAgICBpZiAoY29va2llLnZhbHVlLm1hdGNoKGNvb2tpZVZhbHVlRFF1b3RlVmFsaWRhdGVSZWdFeCkpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciA9IGNvb2tpZS52YWx1ZS5zbGljZSgxLCAtMSkubWF0Y2goY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUudmFsdWUubWF0Y2goY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnZhbGlkQ2hhcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29va2llUGFydHMgPSBbY29va2llLm5hbWUgKyAnPScgKyBjb29raWUudmFsdWVdO1xuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8gJ1BhdGg9JyBwYXRoLXZhbHVlIHwgPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yICc7Jz5cbiAgICAgICAgICAgIGlmKGNvb2tpZS5wYXRoKXtcbiAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhciA9IGNvb2tpZS5wYXRoLm1hdGNoKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4KTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSBwYXRoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ1BhdGg9JyArIGNvb2tpZS5wYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjIuM1xuICAgICAgICAgICAgLy8gJ0RvbWFpbj0nIHN1YmRvbWFpblxuICAgICAgICAgICAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNvb2tpZS5kb21haW4pICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvbWFpbiBtdXN0IGJlIHNwZWNpZmllZCBhbmQgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUuZG9tYWluLm1hdGNoKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4KTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciAnICsgaW52YWxpZENoYXJbMF0gKyAnIGluIGNvb2tpZSBkb21haW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnRG9tYWluPScgKyBjb29raWUuZG9tYWluLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nRXhwaXJlcz0nIHNhbmUtY29va2llLWRhdGUgfCBGb3JjZSBEYXRlIG9iamVjdCByZXF1aXJlbWVudCBieSB1c2luZyBvbmx5IGVwb2NoXG4gICAgICAgICAgICBpZiAoY29va2llLmV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjb29raWUuZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBzdXBwbGllZCBmb3IgY29va2llIFwiZXhwaXJlc1wiIG11c3QgYmUgYSB2YWlsZCBkYXRlIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdFeHBpcmVzPScgKyBjb29raWUuZXhwaXJlcy50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ01heC1BZ2U9JyBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgICAgIGlmIChjb29raWUubWF4YWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heGFnZSA9IGNvb2tpZS5tYXhhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihtYXhhZ2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBtYXhhZ2UgPSBwYXJzZUludChtYXhhZ2UsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG1heGFnZSkgfHwgbWF4YWdlIDw9IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcIm1heGFnZVwiIG11c3QgYmUgYSBub24temVybyBudW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF4YWdlID0gTWF0aC5yb3VuZChtYXhhZ2UpO1xuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ01heC1BZ2U9JyArIG1heGFnZS50b1N0cmluZygxMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nU2VjdXJlOydcbiAgICAgICAgICAgIGlmIChjb29raWUuc2VjdXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb29raWUuc2VjdXJlKSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcInNlY3VyZVwiIG11c3QgYmUgb2YgdHlwZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ1NlY3VyZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8nSHR0cE9ubHk7J1xuICAgICAgICAgICAgaWYgKGNvb2tpZS5odHRwb25seSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29va2llLmh0dHBvbmx5KSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcImh0dHBvbmx5XCIgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnSHR0cE9ubHknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzcG9uc2UgKz0gKCdTZXQtQ29va2llOiAnICsgY29va2llUGFydHMuam9pbignOycpICsgJ1xcclxcbicpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGhhbmRsZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICAvLyBpZiAobmVnb3RpYXRlZEV4dGVuc2lvbnMpIHtcbiAgICAvLyAgICAgcmVzcG9uc2UgKz0gJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJyArIG5lZ290aWF0ZWRFeHRlbnNpb25zLmpvaW4oJywgJykgKyAnXFxyXFxuJztcbiAgICAvLyB9XG5cbiAgICAvLyBNYXJrIHRoZSByZXF1ZXN0IHJlc29sdmVkIG5vdyBzbyB0aGF0IHRoZSB1c2VyIGNhbid0IGNhbGwgYWNjZXB0IG9yXG4gICAgLy8gcmVqZWN0IGEgc2Vjb25kIHRpbWUuXG4gICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlc29sdmVkJywgdGhpcyk7XG5cbiAgICByZXNwb25zZSArPSAnXFxyXFxuJztcblxuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldENvbm5lY3Rpb24odGhpcy5zb2NrZXQsIFtdLCBhY2NlcHRlZFByb3RvY29sLCBmYWxzZSwgdGhpcy5zZXJ2ZXJDb25maWcpO1xuICAgIGNvbm5lY3Rpb24ud2ViU29ja2V0VmVyc2lvbiA9IHRoaXMud2ViU29ja2V0VmVyc2lvbjtcbiAgICBjb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MgPSB0aGlzLnJlbW90ZUFkZHJlc3M7XG4gICAgY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzZXMgPSB0aGlzLnJlbW90ZUFkZHJlc3NlcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9zb2NrZXRJc0Nsb3NpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0aGUgY2xpZW50IGhhbmdzIHVwIGJlZm9yZSB3ZSBnZXQgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gYWNjZXB0IHRoZSBjb25uZWN0aW9uIGFuZCBzZW5kIG91ciBzaWRlIG9mIHRoZSBvcGVuaW5nIGhhbmRzaGFrZS5cbiAgICAgICAgY2xlYW51cEZhaWxlZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShyZXNwb25zZSwgJ2FzY2lpJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNsZWFudXBGYWlsZWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5fcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgncmVxdWVzdEFjY2VwdGVkJywgY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihzdGF0dXMsIHJlYXNvbiwgZXh0cmFIZWFkZXJzKSB7XG4gICAgdGhpcy5fdmVyaWZ5UmVzb2x1dGlvbigpO1xuXG4gICAgLy8gTWFyayB0aGUgcmVxdWVzdCByZXNvbHZlZCBub3cgc28gdGhhdCB0aGUgdXNlciBjYW4ndCBjYWxsIGFjY2VwdCBvclxuICAgIC8vIHJlamVjdCBhIHNlY29uZCB0aW1lLlxuICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZXNvbHZlZCcsIHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZihzdGF0dXMpICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdGF0dXMgPSA0MDM7XG4gICAgfVxuICAgIHZhciByZXNwb25zZSA9ICdIVFRQLzEuMSAnICsgc3RhdHVzICsgJyAnICsgaHR0cFN0YXR1c0Rlc2NyaXB0aW9uc1tzdGF0dXNdICsgJ1xcclxcbicgK1xuICAgICAgICAgICAgICAgICAgICdDb25uZWN0aW9uOiBjbG9zZVxcclxcbic7XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgICByZWFzb24gPSByZWFzb24ucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICByZXNwb25zZSArPSAnWC1XZWJTb2NrZXQtUmVqZWN0LVJlYXNvbjogJyArIHJlYXNvbiArICdcXHJcXG4nO1xuICAgIH1cblxuICAgIGlmIChleHRyYUhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gZXh0cmFIZWFkZXJzW2tleV0udG9TdHJpbmcoKS5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkS2V5ID0ga2V5LnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIHJlc3BvbnNlICs9IChzYW5pdGl6ZWRLZXkgKyAnOiAnICsgc2FuaXRpemVkVmFsdWUgKyAnXFxyXFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNwb25zZSArPSAnXFxyXFxuJztcbiAgICB0aGlzLnNvY2tldC5lbmQocmVzcG9uc2UsICdhc2NpaScpO1xuXG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0UmVqZWN0ZWQnLCB0aGlzKTtcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLl9oYW5kbGVTb2NrZXRDbG9zZUJlZm9yZUFjY2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NvY2tldElzQ2xvc2luZyA9IHRydWU7XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFJlcXVlc3QucHJvdG90eXBlLl9yZW1vdmVTb2NrZXRDbG9zZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xuICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlcik7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5fdmVyaWZ5UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldFJlcXVlc3QgbWF5IG9ubHkgYmUgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgb25lIHRpbWUuJyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2xlYW51cEZhaWxlZENvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgIC8vIFNpbmNlIHdlIGhhdmUgdG8gcmV0dXJuIGEgY29ubmVjdGlvbiBvYmplY3QgZXZlbiBpZiB0aGUgc29ja2V0IGlzXG4gICAgLy8gYWxyZWFkeSBkZWFkIGluIG9yZGVyIG5vdCB0byBicmVhayB0aGUgQVBJLCB3ZSBzY2hlZHVsZSBhICdjbG9zZSdcbiAgICAvLyBldmVudCBvbiB0aGUgY29ubmVjdGlvbiBvYmplY3QgdG8gb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUwgPSAxMDA2XG4gICAgICAgIC8vIFRoaXJkIHBhcmFtOiBTa2lwIHNlbmRpbmcgdGhlIGNsb3NlIGZyYW1lIHRvIGEgZGVhZCBzb2NrZXRcbiAgICAgICAgY29ubmVjdGlvbi5kcm9wKDEwMDYsICdUQ1AgY29ubmVjdGlvbiBsb3N0IGJlZm9yZSBoYW5kc2hha2UgY29tcGxldGVkLicsIHRydWUpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJlcXVlc3Q7XG4iXSwibmFtZXMiOlsiY3J5cHRvIiwicmVxdWlyZSIsInV0aWwiLCJ1cmwiLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRDb25uZWN0aW9uIiwiaGVhZGVyVmFsdWVTcGxpdFJlZ0V4cCIsImhlYWRlclBhcmFtU3BsaXRSZWdFeHAiLCJoZWFkZXJTYW5pdGl6ZVJlZ0V4cCIsInhGb3J3YXJkZWRGb3JTZXBhcmF0b3JSZWdFeHAiLCJzZXBhcmF0b3JzIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY29udHJvbENoYXJzIiwiaSIsInB1c2giLCJjb29raWVOYW1lVmFsaWRhdGVSZWdFeCIsImNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCIsImNvb2tpZVZhbHVlRFF1b3RlVmFsaWRhdGVSZWdFeCIsImNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4IiwiY29va2llU2VwYXJhdG9yUmVnRXgiLCJodHRwU3RhdHVzRGVzY3JpcHRpb25zIiwiV2ViU29ja2V0UmVxdWVzdCIsInNvY2tldCIsImh0dHBSZXF1ZXN0Iiwic2VydmVyQ29uZmlnIiwiY2FsbCIsInJlc291cmNlIiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZUFkZHJlc3NlcyIsIl9zb2NrZXRJc0Nsb3NpbmciLCJfc29ja2V0Q2xvc2VIYW5kbGVyIiwiX2hhbmRsZVNvY2tldENsb3NlQmVmb3JlQWNjZXB0IiwiYmluZCIsIm9uIiwiX3Jlc29sdmVkIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJyZWFkSGFuZHNoYWtlIiwic2VsZiIsInJlcXVlc3QiLCJyZXNvdXJjZVVSTCIsInBhcnNlIiwiaG9zdCIsImhlYWRlcnMiLCJFcnJvciIsImtleSIsIndlYlNvY2tldFZlcnNpb24iLCJwYXJzZUludCIsImlzTmFOIiwiZSIsImh0dHBDb2RlIiwib3JpZ2luIiwicHJvdG9jb2xTdHJpbmciLCJwcm90b2NvbEZ1bGxDYXNlTWFwIiwicmVxdWVzdGVkUHJvdG9jb2xzIiwicmVxdWVzdGVkUHJvdG9jb2xzRnVsbENhc2UiLCJzcGxpdCIsImZvckVhY2giLCJwcm90b2NvbCIsImxjUHJvdG9jb2wiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImlnbm9yZVhGb3J3YXJkZWRGb3IiLCJpbW1lZGlhdGVQZWVySVAiLCJwYXJzZUV4dGVuc2lvbnMiLCJleHRlbnNpb25zU3RyaW5nIiwicmVxdWVzdGVkRXh0ZW5zaW9ucyIsInBhcnNlQ29va2llcyIsImNvb2tpZVN0cmluZyIsImNvb2tpZXMiLCJsZW5ndGgiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uIiwiaW5kZXgiLCJhcnJheSIsInBhcmFtcyIsImV4dGVuc2lvbk5hbWUiLCJleHRlbnNpb25QYXJhbXMiLCJzbGljZSIsInJhd1BhcmFtIiwiYXJyIiwib2JqIiwibmFtZSIsInZhbHVlIiwic3BsaWNlIiwic3RyIiwicGFpcnMiLCJwYWlyIiwiZXFfaWR4IiwiaW5kZXhPZiIsInN1YnN0ciIsInRyaW0iLCJ2YWwiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhY2NlcHQiLCJhY2NlcHRlZFByb3RvY29sIiwiYWxsb3dlZE9yaWdpbiIsIl92ZXJpZnlSZXNvbHV0aW9uIiwicHJvdG9jb2xGdWxsQ2FzZSIsInNoYTEiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiYWNjZXB0S2V5IiwiZGlnZXN0IiwicmVzcG9uc2UiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJjaGFyYWN0ZXIiLCJjaGFyQXQiLCJyZWplY3QiLCJyZXBsYWNlIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VlbkNvb2tpZXMiLCJjb29raWUiLCJpbnZhbGlkQ2hhciIsIm1hdGNoIiwiY29va2llUGFydHMiLCJwYXRoIiwiZG9tYWluIiwidG9Mb3dlckNhc2UiLCJleHBpcmVzIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwibWF4YWdlIiwiTWF0aCIsInJvdW5kIiwidG9TdHJpbmciLCJzZWN1cmUiLCJodHRwb25seSIsImpvaW4iLCJlbWl0IiwiY29ubmVjdGlvbiIsImNsZWFudXBGYWlsZWRDb25uZWN0aW9uIiwid3JpdGUiLCJlcnJvciIsIl9yZW1vdmVTb2NrZXRDbG9zZUxpc3RlbmVycyIsIl9hZGRTb2NrZXRFdmVudExpc3RlbmVycyIsInN0YXR1cyIsInJlYXNvbiIsImV4dHJhSGVhZGVycyIsInNhbml0aXplZFZhbHVlIiwic2FuaXRpemVkS2V5IiwiZW5kIiwicmVtb3ZlTGlzdGVuZXIiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJkcm9wIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketRequest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouter.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar extend = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").extend);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ \"(rsc)/./node_modules/websocket/lib/WebSocketRouterRequest.js\");\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\nutil.inherits(WebSocketRouter, EventEmitter);\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on(\"request\", this._requestHandler);\n    } else {\n        throw new Error(\"You must specify a WebSocketServer instance to attach to.\");\n    }\n};\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener(\"request\", this._requestHandler);\n        this.server = null;\n    } else {\n        throw new Error(\"Cannot detach from server: not attached.\");\n    }\n};\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error(\"You must specify a path for this handler.\");\n    }\n    if (!protocol) {\n        protocol = \"____no_protocol____\";\n    }\n    if (!callback) {\n        throw new Error(\"You must specify a callback for this handler.\");\n    }\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error(\"Path must be specified as either a string or a RegExp.\");\n    }\n    var pathString = path.toString();\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error(\"You may only mount one handler per path/protocol combination.\");\n    }\n    this.handlers.push({\n        \"path\": path,\n        \"pathString\": pathString,\n        \"protocol\": protocol,\n        \"callback\": callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    } else {\n        throw new Error(\"Unable to find a route matching the specified path and protocol.\");\n    }\n};\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for(var i = 0, len = this.handlers.length; i < len; i++){\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof path === \"string\") {\n        if (path === \"*\") {\n            path = /^.*$/;\n        } else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n            path = new RegExp(\"^\" + path + \"$\");\n        }\n    }\n    return path;\n};\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = [\n            \"____no_protocol____\"\n        ];\n    }\n    // Find a handler with the first requested protocol first\n    for(var i = 0; i < requestedProtocols.length; i++){\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n        // find the first handler that can process this request\n        for(var j = 0, len = this.handlers.length; j < len; j++){\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol || handler.protocol === \"*\") {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, \"No handler is available for the given request.\");\n};\nmodule.exports = WebSocketRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxTQUFTQywwRkFBeUI7QUFDdEMsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsZUFBZUYsMERBQThCO0FBQ2pELElBQUlHLHlCQUF5QkgsbUJBQU9BLENBQUM7QUFFckMsU0FBU0ksZ0JBQWdCQyxNQUFNO0lBQzNCLHlCQUF5QjtJQUN6QkgsYUFBYUksSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDRCxNQUFNLEdBQUc7UUFDViw2Q0FBNkM7UUFDN0NFLFFBQVE7SUFDWjtJQUNBLElBQUlGLFFBQVE7UUFDUk4sT0FBTyxJQUFJLENBQUNNLE1BQU0sRUFBRUE7SUFDeEI7SUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBRyxFQUFFO0lBRWxCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUNuRCxJQUFJLElBQUksQ0FBQ04sTUFBTSxDQUFDRSxNQUFNLEVBQUU7UUFDcEIsSUFBSSxDQUFDSyxZQUFZLENBQUMsSUFBSSxDQUFDUCxNQUFNLENBQUNFLE1BQU07SUFDeEM7QUFDSjtBQUVBTixLQUFLWSxRQUFRLENBQUNULGlCQUFpQkY7QUFFL0JFLGdCQUFnQlUsU0FBUyxDQUFDRixZQUFZLEdBQUcsU0FBU0wsTUFBTTtJQUNwRCxJQUFJQSxRQUFRO1FBQ1IsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQSxNQUFNLENBQUNRLEVBQUUsQ0FBQyxXQUFXLElBQUksQ0FBQ04sZUFBZTtJQUNsRCxPQUNLO1FBQ0QsTUFBTSxJQUFJTyxNQUFNO0lBQ3BCO0FBQ0o7QUFFQVosZ0JBQWdCVSxTQUFTLENBQUNHLFlBQVksR0FBRztJQUNyQyxJQUFJLElBQUksQ0FBQ1YsTUFBTSxFQUFFO1FBQ2Is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RU0sSUFBSVAsS0FBS08sSUFBSztZQUNsRCxJQUFJTCxVQUFVLElBQUksQ0FBQzVCLFFBQVEsQ0FBQ2lDLEVBQUU7WUFDOUIsSUFBSUwsUUFBUWhCLElBQUksQ0FBQ3NCLElBQUksQ0FBQ0osUUFBUUssV0FBVyxDQUFDQyxRQUFRLEdBQUc7Z0JBQ2pELElBQUlKLHNCQUFzQkosUUFBUWYsUUFBUSxJQUN0Q2UsUUFBUWYsUUFBUSxLQUFLLEtBQ3pCO29CQUNJLElBQUl3QixnQkFBZ0IsSUFBSTFDLHVCQUF1Qm1DLFNBQVNFO29CQUN4REosUUFBUWQsUUFBUSxDQUFDdUI7b0JBQ2pCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBRUEsNERBQTREO0lBQzVEUCxRQUFRUSxNQUFNLENBQUMsS0FBSztBQUN4QjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJvdXRlci5qcz85MWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbHMnKS5leHRlbmQ7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgV2ViU29ja2V0Um91dGVyUmVxdWVzdCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0Um91dGVyUmVxdWVzdCcpO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRSb3V0ZXIoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIC8vIFRoZSBXZWJTb2NrZXRTZXJ2ZXIgaW5zdGFuY2UgdG8gYXR0YWNoIHRvLlxuICAgICAgICBzZXJ2ZXI6IG51bGxcbiAgICB9O1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMuY29uZmlnLCBjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG5cbiAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IHRoaXMuaGFuZGxlUmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hTZXJ2ZXIodGhpcy5jb25maWcuc2VydmVyKTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Um91dGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmF0dGFjaFNlcnZlciA9IGZ1bmN0aW9uKHNlcnZlcikge1xuICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMuc2VydmVyLm9uKCdyZXF1ZXN0JywgdGhpcy5fcmVxdWVzdEhhbmRsZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgV2ViU29ja2V0U2VydmVyIGluc3RhbmNlIHRvIGF0dGFjaCB0by4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmRldGFjaFNlcnZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlcnZlcikge1xuICAgICAgICB0aGlzLnNlcnZlci5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIHRoaXMuX3JlcXVlc3RIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0YWNoIGZyb20gc2VydmVyOiBub3QgYXR0YWNoZWQuJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uKHBhdGgsIHByb3RvY29sLCBjYWxsYmFjaykge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBwYXRoIGZvciB0aGlzIGhhbmRsZXIuJyk7XG4gICAgfVxuICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgcHJvdG9jb2wgPSAnX19fX25vX3Byb3RvY29sX19fXyc7XG4gICAgfVxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY2FsbGJhY2sgZm9yIHRoaXMgaGFuZGxlci4nKTtcbiAgICB9XG5cbiAgICBwYXRoID0gdGhpcy5wYXRoVG9SZWdFeHAocGF0aCk7XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhIHN0cmluZyBvciBhIFJlZ0V4cC4nKTtcbiAgICB9XG4gICAgdmFyIHBhdGhTdHJpbmcgPSBwYXRoLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBub3JtYWxpemUgcHJvdG9jb2wgdG8gbG93ZXItY2FzZVxuICAgIHByb3RvY29sID0gcHJvdG9jb2wudG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICAgIGlmICh0aGlzLmZpbmRIYW5kbGVySW5kZXgocGF0aFN0cmluZywgcHJvdG9jb2wpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgb25seSBtb3VudCBvbmUgaGFuZGxlciBwZXIgcGF0aC9wcm90b2NvbCBjb21iaW5hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgICAncGF0aCc6IHBhdGgsXG4gICAgICAgICdwYXRoU3RyaW5nJzogcGF0aFN0cmluZyxcbiAgICAgICAgJ3Byb3RvY29sJzogcHJvdG9jb2wsXG4gICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrXG4gICAgfSk7XG59O1xuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24ocGF0aCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRIYW5kbGVySW5kZXgodGhpcy5wYXRoVG9SZWdFeHAocGF0aCkudG9TdHJpbmcoKSwgcHJvdG9jb2wpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIHJvdXRlIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcGF0aCBhbmQgcHJvdG9jb2wuJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5maW5kSGFuZGxlckluZGV4ID0gZnVuY3Rpb24ocGF0aFN0cmluZywgcHJvdG9jb2wpIHtcbiAgICBwcm90b2NvbCA9IHByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgZm9yICh2YXIgaT0wLCBsZW49dGhpcy5oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbaV07XG4gICAgICAgIGlmIChoYW5kbGVyLnBhdGhTdHJpbmcgPT09IHBhdGhTdHJpbmcgJiYgaGFuZGxlci5wcm90b2NvbCA9PT0gcHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUucGF0aFRvUmVnRXhwID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICh0eXBlb2YocGF0aCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChwYXRoID09PSAnKicpIHtcbiAgICAgICAgICAgIHBhdGggPSAvXi4qJC87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICAgICAgICAgICAgcGF0aCA9IG5ldyBSZWdFeHAoJ14nICsgcGF0aCArICckJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHJlcXVlc3RlZFByb3RvY29scyA9IHJlcXVlc3QucmVxdWVzdGVkUHJvdG9jb2xzO1xuICAgIGlmIChyZXF1ZXN0ZWRQcm90b2NvbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlcXVlc3RlZFByb3RvY29scyA9IFsnX19fX25vX3Byb3RvY29sX19fXyddO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYSBoYW5kbGVyIHdpdGggdGhlIGZpcnN0IHJlcXVlc3RlZCBwcm90b2NvbCBmaXJzdFxuICAgIGZvciAodmFyIGk9MDsgaSA8IHJlcXVlc3RlZFByb3RvY29scy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVxdWVzdGVkUHJvdG9jb2wgPSByZXF1ZXN0ZWRQcm90b2NvbHNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRoYXQgY2FuIHByb2Nlc3MgdGhpcyByZXF1ZXN0XG4gICAgICAgIGZvciAodmFyIGo9MCwgbGVuPXRoaXMuaGFuZGxlcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tqXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLnBhdGgudGVzdChyZXF1ZXN0LnJlc291cmNlVVJMLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRQcm90b2NvbCA9PT0gaGFuZGxlci5wcm90b2NvbCB8fFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnByb3RvY29sID09PSAnKicpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVyUmVxdWVzdCA9IG5ldyBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0KHJlcXVlc3QsIHJlcXVlc3RlZFByb3RvY29sKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhyb3V0ZXJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdldCBoZXJlIHdlIHdlcmUgdW5hYmxlIHRvIGZpbmQgYSBzdWl0YWJsZSBoYW5kbGVyLlxuICAgIHJlcXVlc3QucmVqZWN0KDQwNCwgJ05vIGhhbmRsZXIgaXMgYXZhaWxhYmxlIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdC4nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0Um91dGVyO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsInJlcXVpcmUiLCJ1dGlsIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0Um91dGVyUmVxdWVzdCIsIldlYlNvY2tldFJvdXRlciIsImNvbmZpZyIsImNhbGwiLCJzZXJ2ZXIiLCJoYW5kbGVycyIsIl9yZXF1ZXN0SGFuZGxlciIsImhhbmRsZVJlcXVlc3QiLCJiaW5kIiwiYXR0YWNoU2VydmVyIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJvbiIsIkVycm9yIiwiZGV0YWNoU2VydmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJtb3VudCIsInBhdGgiLCJwcm90b2NvbCIsImNhbGxiYWNrIiwicGF0aFRvUmVnRXhwIiwiUmVnRXhwIiwicGF0aFN0cmluZyIsInRvU3RyaW5nIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJmaW5kSGFuZGxlckluZGV4IiwicHVzaCIsInVubW91bnQiLCJpbmRleCIsInNwbGljZSIsImkiLCJsZW4iLCJsZW5ndGgiLCJoYW5kbGVyIiwicmVwbGFjZSIsInJlcXVlc3QiLCJyZXF1ZXN0ZWRQcm90b2NvbHMiLCJyZXF1ZXN0ZWRQcm90b2NvbCIsImoiLCJ0ZXN0IiwicmVzb3VyY2VVUkwiLCJwYXRobmFtZSIsInJvdXRlclJlcXVlc3QiLCJyZWplY3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketRouter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!**************************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === \"____no_protocol____\") {\n        this.protocol = null;\n    } else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\nutil.inherits(WebSocketRouterRequest, EventEmitter);\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit(\"requestRejected\", this);\n};\nmodule.exports = WebSocketRouterRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUU7QUFFdkUsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsZUFBZUQsMERBQThCO0FBRWpELFNBQVNFLHVCQUF1QkMsZ0JBQWdCLEVBQUVDLGdCQUFnQjtJQUM5RCx5QkFBeUI7SUFDekJILGFBQWFJLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUksQ0FBQ0YsZ0JBQWdCLEdBQUdBO0lBQ3hCLElBQUlDLHFCQUFxQix1QkFBdUI7UUFDNUMsSUFBSSxDQUFDRSxRQUFRLEdBQUc7SUFDcEIsT0FDSztRQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFHRjtJQUNwQjtJQUNBLElBQUksQ0FBQ0csTUFBTSxHQUFHSixpQkFBaUJJLE1BQU07SUFDckMsSUFBSSxDQUFDQyxRQUFRLEdBQUdMLGlCQUFpQkssUUFBUTtJQUN6QyxJQUFJLENBQUNDLFdBQVcsR0FBR04saUJBQWlCTSxXQUFXO0lBQy9DLElBQUksQ0FBQ0MsV0FBVyxHQUFHUCxpQkFBaUJPLFdBQVc7SUFDL0MsSUFBSSxDQUFDQyxhQUFhLEdBQUdSLGlCQUFpQlEsYUFBYTtJQUNuRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHVCxpQkFBaUJTLGdCQUFnQjtJQUN6RCxJQUFJLENBQUNDLG1CQUFtQixHQUFHVixpQkFBaUJVLG1CQUFtQjtJQUMvRCxJQUFJLENBQUNDLE9BQU8sR0FBR1gsaUJBQWlCVyxPQUFPO0FBQzNDO0FBRUFmLEtBQUtnQixRQUFRLENBQUNiLHdCQUF3QkQ7QUFFdENDLHVCQUF1QmMsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU1YsTUFBTSxFQUFFTyxPQUFPO0lBQzlELElBQUlJLGFBQWEsSUFBSSxDQUFDZixnQkFBZ0IsQ0FBQ2MsTUFBTSxDQUFDLElBQUksQ0FBQ1gsUUFBUSxFQUFFQyxRQUFRTztJQUNyRSxJQUFJLENBQUNLLElBQUksQ0FBQyxtQkFBbUJEO0lBQzdCLE9BQU9BO0FBQ1g7QUFFQWhCLHVCQUF1QmMsU0FBUyxDQUFDSSxNQUFNLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0UsSUFBSSxDQUFDcEIsZ0JBQWdCLENBQUNpQixNQUFNLENBQUNDLFFBQVFDLFFBQVFDO0lBQzdDLElBQUksQ0FBQ0osSUFBSSxDQUFDLG1CQUFtQixJQUFJO0FBQ3JDO0FBRUFLLE9BQU9DLE9BQU8sR0FBR3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0Um91dGVyUmVxdWVzdC5qcz8zYjk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0KHdlYlNvY2tldFJlcXVlc3QsIHJlc29sdmVkUHJvdG9jb2wpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLndlYlNvY2tldFJlcXVlc3QgPSB3ZWJTb2NrZXRSZXF1ZXN0O1xuICAgIGlmIChyZXNvbHZlZFByb3RvY29sID09PSAnX19fX25vX3Byb3RvY29sX19fXycpIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcmVzb2x2ZWRQcm90b2NvbDtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW4gPSB3ZWJTb2NrZXRSZXF1ZXN0Lm9yaWdpbjtcbiAgICB0aGlzLnJlc291cmNlID0gd2ViU29ja2V0UmVxdWVzdC5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc291cmNlVVJMID0gd2ViU29ja2V0UmVxdWVzdC5yZXNvdXJjZVVSTDtcbiAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gd2ViU29ja2V0UmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB3ZWJTb2NrZXRSZXF1ZXN0LnJlbW90ZUFkZHJlc3M7XG4gICAgdGhpcy53ZWJTb2NrZXRWZXJzaW9uID0gd2ViU29ja2V0UmVxdWVzdC53ZWJTb2NrZXRWZXJzaW9uO1xuICAgIHRoaXMucmVxdWVzdGVkRXh0ZW5zaW9ucyA9IHdlYlNvY2tldFJlcXVlc3QucmVxdWVzdGVkRXh0ZW5zaW9ucztcbiAgICB0aGlzLmNvb2tpZXMgPSB3ZWJTb2NrZXRSZXF1ZXN0LmNvb2tpZXM7XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Um91dGVyUmVxdWVzdCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Um91dGVyUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24ob3JpZ2luLCBjb29raWVzKSB7XG4gICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLndlYlNvY2tldFJlcXVlc3QuYWNjZXB0KHRoaXMucHJvdG9jb2wsIG9yaWdpbiwgY29va2llcyk7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0QWNjZXB0ZWQnLCBjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG5cbldlYlNvY2tldFJvdXRlclJlcXVlc3QucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHN0YXR1cywgcmVhc29uLCBleHRyYUhlYWRlcnMpIHtcbiAgICB0aGlzLndlYlNvY2tldFJlcXVlc3QucmVqZWN0KHN0YXR1cywgcmVhc29uLCBleHRyYUhlYWRlcnMpO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlamVjdGVkJywgdGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJvdXRlclJlcXVlc3Q7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0Iiwid2ViU29ja2V0UmVxdWVzdCIsInJlc29sdmVkUHJvdG9jb2wiLCJjYWxsIiwicHJvdG9jb2wiLCJvcmlnaW4iLCJyZXNvdXJjZSIsInJlc291cmNlVVJMIiwiaHR0cFJlcXVlc3QiLCJyZW1vdGVBZGRyZXNzIiwid2ViU29ja2V0VmVyc2lvbiIsInJlcXVlc3RlZEV4dGVuc2lvbnMiLCJjb29raWVzIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJhY2NlcHQiLCJjb25uZWN0aW9uIiwiZW1pdCIsInJlamVjdCIsInN0YXR1cyIsInJlYXNvbiIsImV4dHJhSGVhZGVycyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketRouterRequest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/WebSocketServer.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketServer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ \nvar extend = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").extend);\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\")(\"websocket:server\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ \"(rsc)/./node_modules/websocket/lib/WebSocketRequest.js\");\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\nutil.inherits(WebSocketServer, EventEmitter);\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [\n                this.config.httpServer\n            ];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on(\"upgrade\", upgradeHandler);\n        });\n    } else {\n        throw new Error(\"You must specify an httpServer on which to mount the WebSocket server.\");\n    }\n};\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener(\"upgrade\", upgradeHandler);\n    });\n};\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n            request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    } else if (typeof data.toString === \"function\") {\n        this.broadcastUTF(data);\n    }\n};\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    } catch (e) {\n        wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);\n        debug(\"Invalid handshake: %s\", e.message);\n        this.emit(\"upgradeError\", e);\n        return;\n    }\n    this.pendingRequests.push(wsRequest);\n    wsRequest.once(\"requestAccepted\", this._handlers.requestAccepted);\n    wsRequest.once(\"requestResolved\", this._handlers.requestResolved);\n    socket.once(\"close\", function() {\n        self._handlers.requestResolved(wsRequest);\n    });\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, \"request\") > 0) {\n        this.emit(\"request\", wsRequest);\n    } else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    } else {\n        wsRequest.reject(404, \"No handler is configured to accept the connection.\");\n    }\n};\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once(\"close\", function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit(\"connect\", connection);\n};\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit(\"close\", connection, closeReason, description);\n};\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) {\n        this.pendingRequests.splice(index, 1);\n    }\n};\nmodule.exports = WebSocketServer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RTtBQUV2RSxJQUFJQSxTQUFTQywwRkFBeUI7QUFDdEMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUMsd0RBQVM7QUFDN0IsSUFBSUksZUFBZUosMERBQThCO0FBQ2pELElBQUlLLG1CQUFtQkwsbUJBQU9BLENBQUM7QUFFL0IsSUFBSU0sa0JBQWtCLFNBQVNBLGdCQUFnQkMsTUFBTTtJQUNqRCx5QkFBeUI7SUFDekJILGFBQWFJLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2JDLFNBQVMsSUFBSSxDQUFDQyxhQUFhLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ3JDQyxpQkFBaUIsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDckRHLGlCQUFpQixJQUFJLENBQUNDLHFCQUFxQixDQUFDSixJQUFJLENBQUMsSUFBSTtJQUN6RDtJQUNBLElBQUksQ0FBQ0ssV0FBVyxHQUFHLEVBQUU7SUFDckIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtJQUN6QixJQUFJWCxRQUFRO1FBQ1IsSUFBSSxDQUFDWSxLQUFLLENBQUNaO0lBQ2Y7QUFDSjtBQUVBTCxLQUFLa0IsUUFBUSxDQUFDZCxpQkFBaUJGO0FBRS9CRSxnQkFBZ0JlLFNBQVMsQ0FBQ0YsS0FBSyxHQUFHLFNBQVNaLE1BQU07SUFDN0MsSUFBSSxDQUFDQSxNQUFNLEdBQUc7UUFDVixvREFBb0Q7UUFDcERlLFlBQVk7UUFFWix3QkFBd0I7UUFDeEJDLHNCQUFzQjtRQUV0Qiw0Q0FBNEM7UUFDNUMsNEJBQTRCO1FBQzVCQyx3QkFBd0I7UUFFeEIsK0RBQStEO1FBQy9ELGlDQUFpQztRQUNq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TUFBTSxDQUFDRixPQUFPO0lBQ25DO0lBQ0EsSUFBSSxDQUFDVixJQUFJLENBQUMsU0FBUzFCLFlBQVlpQyxhQUFhQztBQUNoRDtBQUVBNUUsZ0JBQWdCZSxTQUFTLENBQUNMLHFCQUFxQixHQUFHLFNBQVNrQyxPQUFPO0lBQzlELElBQUlrQyxRQUFRLElBQUksQ0FBQ2xFLGVBQWUsQ0FBQ21FLE9BQU8sQ0FBQ25DO0lBQ3pDLElBQUlrQyxVQUFVLENBQUMsR0FBRztRQUFFLElBQUksQ0FBQ2xFLGVBQWUsQ0FBQ29FLE1BQU0sQ0FBQ0YsT0FBTztJQUFJO0FBQy9EO0FBRUFHLE9BQU9DLE9BQU8sR0FBR2xGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0U2VydmVyLmpzP2FkYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscycpLmV4dGVuZDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2Vic29ja2V0OnNlcnZlcicpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRSZXF1ZXN0Jyk7XG5cbnZhciBXZWJTb2NrZXRTZXJ2ZXIgPSBmdW5jdGlvbiBXZWJTb2NrZXRTZXJ2ZXIoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5faGFuZGxlcnMgPSB7XG4gICAgICAgIHVwZ3JhZGU6IHRoaXMuaGFuZGxlVXBncmFkZS5iaW5kKHRoaXMpLFxuICAgICAgICByZXF1ZXN0QWNjZXB0ZWQ6IHRoaXMuaGFuZGxlUmVxdWVzdEFjY2VwdGVkLmJpbmQodGhpcyksXG4gICAgICAgIHJlcXVlc3RSZXNvbHZlZDogdGhpcy5oYW5kbGVSZXF1ZXN0UmVzb2x2ZWQuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gW107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgICB0aGlzLm1vdW50KGNvbmZpZyk7XG4gICAgfVxufTtcblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRTZXJ2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLy8gVGhlIGh0dHAgc2VydmVyIGluc3RhbmNlIHRvIGF0dGFjaCB0by4gIFJlcXVpcmVkLlxuICAgICAgICBodHRwU2VydmVyOiBudWxsLFxuXG4gICAgICAgIC8vIDY0S2lCIG1heCBmcmFtZSBzaXplLlxuICAgICAgICBtYXhSZWNlaXZlZEZyYW1lU2l6ZTogMHgxMDAwMCxcblxuICAgICAgICAvLyAxTWlCIG1heCBtZXNzYWdlIHNpemUsIG9ubHkgYXBwbGljYWJsZSBpZlxuICAgICAgICAvLyBhc3NlbWJsZUZyYWdtZW50cyBpcyB0cnVlXG4gICAgICAgIG1heFJlY2VpdmVkTWVzc2FnZVNpemU6IDB4MTAwMDAwLFxuXG4gICAgICAgIC8vIE91dGdvaW5nIG1lc3NhZ2VzIGxhcmdlciB0aGFuIGZyYWdtZW50YXRpb25UaHJlc2hvbGQgd2lsbCBiZVxuICAgICAgICAvLyBzcGxpdCBpbnRvIG11bHRpcGxlIGZyYWdtZW50cy5cbiAgICAgICAgZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzOiB0cnVlLFxuXG4gICAgICAgIC8vIE91dGdvaW5nIGZyYW1lcyBhcmUgZnJhZ21lbnRlZCBpZiB0aGV5IGV4Y2VlZCB0aGlzIHRocmVzaG9sZC5cbiAgICAgICAgLy8gRGVmYXVsdCBpcyAxNktpQlxuICAgICAgICBmcmFnbWVudGF0aW9uVGhyZXNob2xkOiAweDQwMDAsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgdGhlIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBpbmcgdG8gYWxsXG4gICAgICAgIC8vIGNsaWVudHMgZXZlcnkgJ2tlZXBhbGl2ZUludGVydmFsJyBtaWxsaXNlY29uZHMuICBUaGUgdGltZXIgaXNcbiAgICAgICAgLy8gcmVzZXQgb24gYW55IHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgY2xpZW50LlxuICAgICAgICBrZWVwYWxpdmU6IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIGludGVydmFsIHRvIHNlbmQga2VlcGFsaXZlIHBpbmdzIHRvIGNvbm5lY3RlZCBjbGllbnRzIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGlkbGUuICBBbnkgcmVjZWl2ZWQgZGF0YSB3aWxsIHJlc2V0IHRoZSBjb3VudGVyLlxuICAgICAgICBrZWVwYWxpdmVJbnRlcnZhbDogMjAwMDAsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgdGhlIHNlcnZlciB3aWxsIGNvbnNpZGVyIGFueSBjb25uZWN0aW9uIHRoYXQgaGFzIG5vdFxuICAgICAgICAvLyByZWNlaXZlZCBhbnkgZGF0YSB3aXRoaW4gdGhlIGFtb3VudCBvZiB0aW1lIHNwZWNpZmllZCBieVxuICAgICAgICAvLyAna2VlcGFsaXZlR3JhY2VQZXJpb2QnIGFmdGVyIGEga2VlcGFsaXZlIHBpbmcgaGFzIGJlZW4gc2VudCB0b1xuICAgICAgICAvLyBiZSBkZWFkLCBhbmQgd2lsbCBkcm9wIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAvLyBJZ25vcmVkIGlmIGtlZXBhbGl2ZSBpcyBmYWxzZS5cbiAgICAgICAgZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQ6IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYWZ0ZXIgc2VuZGluZyBhIGtlZXBhbGl2ZSBwaW5nIGJlZm9yZVxuICAgICAgICAvLyBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIGlmIHRoZSBjb25uZWN0ZWQgcGVlciBkb2VzIG5vdCByZXNwb25kLlxuICAgICAgICAvLyBJZ25vcmVkIGlmIGtlZXBhbGl2ZSBpcyBmYWxzZS5cbiAgICAgICAga2VlcGFsaXZlR3JhY2VQZXJpb2Q6IDEwMDAwLFxuXG4gICAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIG5hdGl2ZSBUQ1Aga2VlcC1hbGl2ZSBpbnN0ZWFkIG9mIFdlYlNvY2tldHMgcGluZ1xuICAgICAgICAvLyBhbmQgcG9uZyBwYWNrZXRzLiAgTmF0aXZlIFRDUCBrZWVwLWFsaXZlIHNlbmRzIHNtYWxsZXIgcGFja2V0c1xuICAgICAgICAvLyBvbiB0aGUgd2lyZSBhbmQgc28gdXNlcyBiYW5kd2lkdGggbW9yZSBlZmZpY2llbnRseS4gIFRoaXMgbWF5XG4gICAgICAgIC8vIGJlIG1vcmUgaW1wb3J0YW50IHdoZW4gdGFsa2luZyB0byBtb2JpbGUgZGV2aWNlcy5cbiAgICAgICAgLy8gSWYgdGhpcyB2YWx1ZSBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGVzZSB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkOlxuICAgICAgICAvLyAgIGtlZXBhbGl2ZUdyYWNlUGVyaW9kXG4gICAgICAgIC8vICAgZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXRcbiAgICAgICAgdXNlTmF0aXZlS2VlcGFsaXZlOiBmYWxzZSxcblxuICAgICAgICAvLyBJZiB0cnVlLCBmcmFnbWVudGVkIG1lc3NhZ2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBhc3NlbWJsZWRcbiAgICAgICAgLy8gYW5kIHRoZSBmdWxsIG1lc3NhZ2Ugd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdtZXNzYWdlJyBldmVudC5cbiAgICAgICAgLy8gSWYgZmFsc2UsIGVhY2ggZnJhbWUgd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdmcmFtZScgZXZlbnQgYW5kXG4gICAgICAgIC8vIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGJlIHJlc3BvbnNpYmxlIGZvciBhZ2dyZWdhdGluZyBtdWx0aXBsZVxuICAgICAgICAvLyBmcmFnbWVudGVkIGZyYW1lcy4gIFNpbmdsZS1mcmFtZSBtZXNzYWdlcyB3aWxsIGVtaXQgYSAnbWVzc2FnZSdcbiAgICAgICAgLy8gZXZlbnQgaW4gYWRkaXRpb24gdG8gdGhlICdmcmFtZScgZXZlbnQuXG4gICAgICAgIC8vIE1vc3QgdXNlcnMgd2lsbCB3YW50IHRvIGxlYXZlIHRoaXMgc2V0IHRvICd0cnVlJ1xuICAgICAgICBhc3NlbWJsZUZyYWdtZW50czogdHJ1ZSxcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUsIHdlYnNvY2tldCBjb25uZWN0aW9ucyB3aWxsIGJlIGFjY2VwdGVkXG4gICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIHBhdGggYW5kIHByb3RvY29sIHNwZWNpZmllZCBieSB0aGUgY2xpZW50LlxuICAgICAgICAvLyBUaGUgcHJvdG9jb2wgYWNjZXB0ZWQgd2lsbCBiZSB0aGUgZmlyc3QgdGhhdCB3YXMgcmVxdWVzdGVkXG4gICAgICAgIC8vIGJ5IHRoZSBjbGllbnQuICBDbGllbnRzIGZyb20gYW55IG9yaWdpbiB3aWxsIGJlIGFjY2VwdGVkLlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGhlIHNpbXBsZXN0IG9mIGNhc2VzLiAgWW91IHNob3VsZFxuICAgICAgICAvLyBwcm9iYWJseSBsZWF2ZSB0aGlzIHNldCB0byAnZmFsc2UnIGFuZCBpbnNwZWN0IHRoZSByZXF1ZXN0XG4gICAgICAgIC8vIG9iamVjdCB0byBtYWtlIHN1cmUgaXQncyBhY2NlcHRhYmxlIGJlZm9yZSBhY2NlcHRpbmcgaXQuXG4gICAgICAgIGF1dG9BY2NlcHRDb25uZWN0aW9uczogZmFsc2UsXG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgdGhlIFgtRm9yd2FyZGVkLUZvciBoZWFkZXIgc2hvdWxkIGJlIHJlc3BlY3RlZC5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc2V0IHRoaXMgdG8gJ3RydWUnIHdoZW4gYWNjZXB0aW5nIGNvbm5lY3Rpb25zXG4gICAgICAgIC8vIGZyb20gdW50cnVzdGVkIGNsaWVudHMsIGFzIGEgbWFsaWNpb3VzIGNsaWVudCBjb3VsZCBzcG9vZiBpdHNcbiAgICAgICAgLy8gSVAgYWRkcmVzcyBieSBzaW1wbHkgc2V0dGluZyB0aGlzIGhlYWRlci4gIEl0J3MgbWVhbnQgdG8gYmUgYWRkZWRcbiAgICAgICAgLy8gYnkgYSB0cnVzdGVkIHByb3h5IG9yIG90aGVyIGludGVybWVkaWFyeSB3aXRoaW4geW91ciBvd25cbiAgICAgICAgLy8gaW5mcmFzdHJ1Y3R1cmUuXG4gICAgICAgIC8vIFNlZTogIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWC1Gb3J3YXJkZWQtRm9yXG4gICAgICAgIGlnbm9yZVhGb3J3YXJkZWRGb3I6IGZhbHNlLFxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgJ2Nvb2tpZScgaGVhZGVycyBhcmUgcGFyc2VkIGFuZCBleHBvc2VkIGFzIFdlYlNvY2tldFJlcXVlc3QuY29va2llc1xuICAgICAgICBwYXJzZUNvb2tpZXM6IHRydWUsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cnVlLCAnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJyBoZWFkZXJzIGFyZSBwYXJzZWQgYW5kIGV4cG9zZWQgYXMgV2ViU29ja2V0UmVxdWVzdC5yZXF1ZXN0ZWRFeHRlbnNpb25zXG4gICAgICAgIHBhcnNlRXh0ZW5zaW9uczogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgTmFnbGUgQWxnb3JpdGhtIG1ha2VzIG1vcmUgZWZmaWNpZW50IHVzZSBvZiBuZXR3b3JrIHJlc291cmNlc1xuICAgICAgICAvLyBieSBpbnRyb2R1Y2luZyBhIHNtYWxsIGRlbGF5IGJlZm9yZSBzZW5kaW5nIHNtYWxsIHBhY2tldHMgc28gdGhhdFxuICAgICAgICAvLyBtdWx0aXBsZSBtZXNzYWdlcyBjYW4gYmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgZ29pbmcgb250byB0aGVcbiAgICAgICAgLy8gd2lyZS4gIFRoaXMgaG93ZXZlciBjb21lcyBhdCB0aGUgY29zdCBvZiBsYXRlbmN5LCBzbyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBpcyB0byBkaXNhYmxlIGl0LiAgSWYgeW91IGRvbid0IG5lZWQgbG93IGxhdGVuY3kgYW5kIGFyZSBzdHJlYW1pbmdcbiAgICAgICAgLy8gbG90cyBvZiBzbWFsbCBtZXNzYWdlcywgeW91IGNhbiBjaGFuZ2UgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIGRpc2FibGVOYWdsZUFsZ29yaXRobTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBjbG9zZSBmcmFtZVxuICAgICAgICAvLyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IHRvIGNvbWUgYmFjayBiZWZvcmUgZ2l2aW5nIHVwIGFuZCBqdXN0XG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIHNvY2tldC5cbiAgICAgICAgY2xvc2VUaW1lb3V0OiA1MDAwXG4gICAgfTtcbiAgICBleHRlbmQodGhpcy5jb25maWcsIGNvbmZpZyk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuaHR0cFNlcnZlcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jb25maWcuaHR0cFNlcnZlcikpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIgPSBbdGhpcy5jb25maWcuaHR0cFNlcnZlcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZ3JhZGVIYW5kbGVyID0gdGhpcy5faGFuZGxlcnMudXBncmFkZTtcbiAgICAgICAgdGhpcy5jb25maWcuaHR0cFNlcnZlci5mb3JFYWNoKGZ1bmN0aW9uKGh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgICAgIGh0dHBTZXJ2ZXIub24oJ3VwZ3JhZGUnLCB1cGdyYWRlSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGFuIGh0dHBTZXJ2ZXIgb24gd2hpY2ggdG8gbW91bnQgdGhlIFdlYlNvY2tldCBzZXJ2ZXIuJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVwZ3JhZGVIYW5kbGVyID0gdGhpcy5faGFuZGxlcnMudXBncmFkZTtcbiAgICB0aGlzLmNvbmZpZy5odHRwU2VydmVyLmZvckVhY2goZnVuY3Rpb24oaHR0cFNlcnZlcikge1xuICAgICAgICBodHRwU2VydmVyLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgdXBncmFkZUhhbmRsZXIpO1xuICAgIH0pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5jbG9zZUFsbENvbm5lY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlcXVlc3QucmVqZWN0KDUwMyk7IC8vIEhUVFAgNTAzIFNlcnZpY2UgVW5hdmFpbGFibGVcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Qnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihkYXRhLnRvU3RyaW5nKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdFVURihkYXRhKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmJyb2FkY2FzdFVURiA9IGZ1bmN0aW9uKHV0ZkRhdGEpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmRVVEYodXRmRGF0YSk7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmJyb2FkY2FzdEJ5dGVzID0gZnVuY3Rpb24oYmluYXJ5RGF0YSkge1xuICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZEJ5dGVzKGJpbmFyeURhdGEpO1xuICAgIH0pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5zaHV0RG93biA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudW5tb3VudCgpO1xuICAgIHRoaXMuY2xvc2VBbGxDb25uZWN0aW9ucygpO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVVcGdyYWRlID0gZnVuY3Rpb24ocmVxdWVzdCwgc29ja2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3c1JlcXVlc3QgPSBuZXcgV2ViU29ja2V0UmVxdWVzdChzb2NrZXQsIHJlcXVlc3QsIHRoaXMuY29uZmlnKTtcbiAgICB0cnkge1xuICAgICAgICB3c1JlcXVlc3QucmVhZEhhbmRzaGFrZSgpO1xuICAgIH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIHdzUmVxdWVzdC5yZWplY3QoXG4gICAgICAgICAgICBlLmh0dHBDb2RlID8gZS5odHRwQ29kZSA6IDQwMCxcbiAgICAgICAgICAgIGUubWVzc2FnZSxcbiAgICAgICAgICAgIGUuaGVhZGVyc1xuICAgICAgICApO1xuICAgICAgICBkZWJ1ZygnSW52YWxpZCBoYW5kc2hha2U6ICVzJywgZS5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGdyYWRlRXJyb3InLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnB1c2god3NSZXF1ZXN0KTtcblxuICAgIHdzUmVxdWVzdC5vbmNlKCdyZXF1ZXN0QWNjZXB0ZWQnLCB0aGlzLl9oYW5kbGVycy5yZXF1ZXN0QWNjZXB0ZWQpO1xuICAgIHdzUmVxdWVzdC5vbmNlKCdyZXF1ZXN0UmVzb2x2ZWQnLCB0aGlzLl9oYW5kbGVycy5yZXF1ZXN0UmVzb2x2ZWQpO1xuICAgIHNvY2tldC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5faGFuZGxlcnMucmVxdWVzdFJlc29sdmVkKHdzUmVxdWVzdCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLmF1dG9BY2NlcHRDb25uZWN0aW9ucyAmJiB1dGlscy5ldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50KHRoaXMsICdyZXF1ZXN0JykgPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIHdzUmVxdWVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmF1dG9BY2NlcHRDb25uZWN0aW9ucykge1xuICAgICAgICB3c1JlcXVlc3QuYWNjZXB0KHdzUmVxdWVzdC5yZXF1ZXN0ZWRQcm90b2NvbHNbMF0sIHdzUmVxdWVzdC5vcmlnaW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3NSZXF1ZXN0LnJlamVjdCg0MDQsICdObyBoYW5kbGVyIGlzIGNvbmZpZ3VyZWQgdG8gYWNjZXB0IHRoZSBjb25uZWN0aW9uLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdEFjY2VwdGVkID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb25uZWN0aW9uLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY2xvc2VSZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlQ29ubmVjdGlvbkNsb3NlKGNvbm5lY3Rpb24sIGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIGNvbm5lY3Rpb24pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVDb25uZWN0aW9uQ2xvc2UgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjb25uZWN0aW9uLCBjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0UmVzb2x2ZWQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7IHRoaXMucGVuZGluZ1JlcXVlc3RzLnNwbGljZShpbmRleCwgMSk7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsInJlcXVpcmUiLCJ1dGlscyIsInV0aWwiLCJkZWJ1ZyIsIkV2ZW50RW1pdHRlciIsIldlYlNvY2tldFJlcXVlc3QiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJjb25maWciLCJjYWxsIiwiX2hhbmRsZXJzIiwidXBncmFkZSIsImhhbmRsZVVwZ3JhZGUiLCJiaW5kIiwicmVxdWVzdEFjY2VwdGVkIiwiaGFuZGxlUmVxdWVzdEFjY2VwdGVkIiwicmVxdWVzdFJlc29sdmVkIiwiaGFuZGxlUmVxdWVzdFJlc29sdmVkIiwiY29ubmVjdGlvbnMiLCJwZW5kaW5nUmVxdWVzdHMiLCJtb3VudCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiaHR0cFNlcnZlciIsIm1heFJlY2VpdmVkRnJhbWVTaXplIiwibWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSIsImZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyIsImZyYWdtZW50YXRpb25UaHJlc2hvbGQiLCJrZWVwYWxpdmUiLCJrZWVwYWxpdmVJbnRlcnZhbCIsImRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0Iiwia2VlcGFsaXZlR3JhY2VQZXJpb2QiLCJ1c2VOYXRpdmVLZWVwYWxpdmUiLCJhc3NlbWJsZUZyYWdtZW50cyIsImF1dG9BY2NlcHRDb25uZWN0aW9ucyIsImlnbm9yZVhGb3J3YXJkZWRGb3IiLCJwYXJzZUNvb2tpZXMiLCJwYXJzZUV4dGVuc2lvbnMiLCJkaXNhYmxlTmFnbGVBbGdvcml0aG0iLCJjbG9zZVRpbWVvdXQiLCJBcnJheSIsImlzQXJyYXkiLCJ1cGdyYWRlSGFuZGxlciIsImZvckVhY2giLCJvbiIsIkVycm9yIiwidW5tb3VudCIsInJlbW92ZUxpc3RlbmVyIiwiY2xvc2VBbGxDb25uZWN0aW9ucyIsImNvbm5lY3Rpb24iLCJjbG9zZSIsInJlcXVlc3QiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJyZWplY3QiLCJicm9hZGNhc3QiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJicm9hZGNhc3RCeXRlcyIsInRvU3RyaW5nIiwiYnJvYWRjYXN0VVRGIiwidXRmRGF0YSIsInNlbmRVVEYiLCJiaW5hcnlEYXRhIiwic2VuZEJ5dGVzIiwic2h1dERvd24iLCJzb2NrZXQiLCJzZWxmIiwid3NSZXF1ZXN0IiwicmVhZEhhbmRzaGFrZSIsImUiLCJodHRwQ29kZSIsIm1lc3NhZ2UiLCJoZWFkZXJzIiwiZW1pdCIsInB1c2giLCJvbmNlIiwiZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCIsImFjY2VwdCIsInJlcXVlc3RlZFByb3RvY29scyIsIm9yaWdpbiIsImNsb3NlUmVhc29uIiwiZGVzY3JpcHRpb24iLCJoYW5kbGVDb25uZWN0aW9uQ2xvc2UiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/WebSocketServer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/websocket/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var noop = exports.noop = function() {};\nexports.extend = function extend(dest, source) {\n    for(var prop in source){\n        dest[prop] = source[prop];\n    }\n};\nexports.eventEmitterListenerCount = (__webpack_require__(/*! events */ \"events\").EventEmitter.listenerCount) || function(emitter, type) {\n    return emitter.listeners(type).length;\n};\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {\n    return new Buffer(size);\n};\nexports.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {\n    return new Buffer(string, encoding);\n};\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\")(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\nBufferingLogger.prototype.log = function() {\n    this.buffer.push([\n        new Date(),\n        Array.prototype.slice.call(arguments)\n    ]);\n    return this;\n};\nBufferingLogger.prototype.clear = function() {\n    this.buffer = [];\n    return this;\n};\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) {\n        logFunction = this.logFunction;\n    }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== void 0 && formatString !== null) {\n            formatString = \"%s - %s - \" + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxPQUFPQyxZQUFZLEdBQUcsWUFBVztBQUVyQ0EsY0FBYyxHQUFHLFNBQVNDLE9BQU9DLElBQUksRUFBRUMsTUFBTTtJQUN6QyxJQUFLLElBQUlDLFFBQVFELE9BQVE7UUFDckJELElBQUksQ0FBQ0UsS0FBSyxHQUFHRCxNQUFNLENBQUNDLEtBQUs7SUFDN0I7QUFDSjtBQUVBSixpQ0FBaUMsR0FDN0JNLHdFQUE0QyxJQUM1QyxTQUFTRyxPQUFPLEVBQUVDLElBQUk7SUFBSSxPQUFPRCxRQUFRRSxTQUFTLENBQUNELE1BQU1FLE1BQU07QUFBRTtBQUVyRVoseUJBQXlCLEdBQUdjLE9BQU9DLFdBQVcsR0FDMUNELE9BQU9DLFdBQVcsR0FDbEIsU0FBU0MscUJBQXFCQyxJQUFJO0lBQUksT0FBTyxJQUFJSCxPQUFPRztBQUFPO0FBRW5FakIsd0JBQXdCLEdBQUdjLE9BQU9LLElBQUksR0FDbENMLE9BQU9LLElBQUksR0FDWCxTQUFTQyxvQkFBb0JDLE1BQU0sRUFBRUMsUUFBUTtJQUMzQyxPQUFPLElBQUlSLE9BQU9PLFFBQVFDO0FBQzVCO0FBRUp0Qix1QkFBdUIsR0FBRyxTQUFTd0Isc0JBQXNCQyxVQUFVLEVBQUVDLFFBQVE7SUFDekUsSUFBSUMsY0FBY3JCLG1CQUFPQSxDQUFDLHdEQUFTbUI7SUFDbkMsSUFBSUUsWUFBWUMsT0FBTyxFQUFFO1FBQ3JCLElBQUlDLFNBQVMsSUFBSU4sZ0JBQWdCRSxZQUFZQyxVQUFVQztRQUN2RCxJQUFJRyxRQUFRRCxPQUFPRSxHQUFHLENBQUNDLElBQUksQ0FBQ0g7UUFDNUJDLE1BQU1HLFdBQVcsR0FBR0osT0FBT0ksV0FBVyxDQUFDRCxJQUFJLENBQUNIO1FBQzVDQyxNQUFNRixPQUFPLEdBQUdELFlBQVlDLE9BQU87UUFDbkMsT0FBT0U7SUFDWDtJQUNBSCxZQUFZTSxXQUFXLEdBQUdsQztJQUMxQixPQUFPNEI7QUFDWDtBQUVBLFNBQVNKLGdCQUFnQkUsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLFdBQVc7SUFDdEQsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0YsVUFBVSxHQUFHQTtJQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDaEIsSUFBSSxDQUFDUSxNQUFNLEdBQUcsRUFBRTtBQUNwQjtBQUVBWCxnQkFBZ0JZLFNBQVMsQ0FBQ0osR0FBRyxHQUFHO0lBQzlCLElBQUksQ0FBQ0csTUFBTSxDQUFDRSxJQUFJLENBQUM7UUFBRSxJQUFJQztRQUFRQyxNQUFNSCxTQUFTLENBQUNJLEtBQUssQ0FBQ0MsSUFBSSxDQUFDQztLQUFZO0lBQ3RFLE9BQU8sSUFBSTtBQUNiO0FBRUFsQixnQkFBZ0JZLFNBQVMsQ0FBQ08sS0FBSyxHQUFHO0lBQ2hDLElBQUksQ0FBQ1IsTUFBTSxHQUFHLEVBQUU7SUFDaEIsT0FBTyxJQUFJO0FBQ2I7QUFFQVgsZ0JBQWdCWSxTQUFTLENBQUNGLFdBQVcsR0FBRyxTQUFTTixXQUFXO0lBQ3hELElBQUksQ0FBQ0EsYUFBYTtRQUFFQSxjQUFjLElBQUksQ0FBQ0EsV0FBVztJQUFFO0lBQ3BELElBQUlELFdBQVcsSUFBSSxDQUFDQSxRQUFRO0lBQzVCLElBQUksQ0FBQ1EsTUFBTSxDQUFDUyxPQUFPLENBQUMsU0FBU0MsS0FBSztRQUM5QixJQUFJQyxPQUFPRCxLQUFLLENBQUMsRUFBRSxDQUFDRSxjQUFjO1FBQ2xDLElBQUlDLE9BQU9ILEtBQUssQ0FBQyxFQUFFLENBQUNMLEtBQUs7UUFDekIsSUFBSVMsZUFBZUQsSUFBSSxDQUFDLEVBQUU7UUFDMUIsSUFBSUMsaUJBQWtCLEtBQUssS0FBTUEsaUJBQWlCLE1BQU07WUFDcERBLGVBQWUsZUFBZUEsYUFBYUMsUUFBUTtZQUNuREYsS0FBS0csTUFBTSxDQUFDLEdBQUcsR0FBR0YsY0FBY0gsTUFBTW5CO1lBQ3RDQyxZQUFZd0IsS0FBSyxDQUFDQyxRQUFRTDtRQUM5QjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcz8xZTZiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBub29wID0gZXhwb3J0cy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCA9XG4gICAgcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgfHxcbiAgICBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7IHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7IH07XG5cbmV4cG9ydHMuYnVmZmVyQWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgP1xuICAgIEJ1ZmZlci5hbGxvY1Vuc2FmZSA6XG4gICAgZnVuY3Rpb24gb2xkQnVmZmVyQWxsb2NVbnNhZmUoc2l6ZSkgeyByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTsgfTtcblxuZXhwb3J0cy5idWZmZXJGcm9tU3RyaW5nID0gQnVmZmVyLmZyb20gP1xuICAgIEJ1ZmZlci5mcm9tIDpcbiAgICBmdW5jdGlvbiBvbGRCdWZmZXJGcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHN0cmluZywgZW5jb2RpbmcpO1xuICAgIH07XG5cbmV4cG9ydHMuQnVmZmVyaW5nTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlEKSB7XG4gICAgdmFyIGxvZ0Z1bmN0aW9uID0gcmVxdWlyZSgnZGVidWcnKShpZGVudGlmaWVyKTtcbiAgICBpZiAobG9nRnVuY3Rpb24uZW5hYmxlZCkge1xuICAgICAgICB2YXIgbG9nZ2VyID0gbmV3IEJ1ZmZlcmluZ0xvZ2dlcihpZGVudGlmaWVyLCB1bmlxdWVJRCwgbG9nRnVuY3Rpb24pO1xuICAgICAgICB2YXIgZGVidWcgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyKTtcbiAgICAgICAgZGVidWcucHJpbnRPdXRwdXQgPSBsb2dnZXIucHJpbnRPdXRwdXQuYmluZChsb2dnZXIpO1xuICAgICAgICBkZWJ1Zy5lbmFibGVkID0gbG9nRnVuY3Rpb24uZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICBsb2dGdW5jdGlvbi5wcmludE91dHB1dCA9IG5vb3A7XG4gICAgcmV0dXJuIGxvZ0Z1bmN0aW9uO1xufTtcblxuZnVuY3Rpb24gQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlELCBsb2dGdW5jdGlvbikge1xuICAgIHRoaXMubG9nRnVuY3Rpb24gPSBsb2dGdW5jdGlvbjtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgIHRoaXMudW5pcXVlSUQgPSB1bmlxdWVJRDtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xufVxuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlci5wdXNoKFsgbmV3IERhdGUoKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSBdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyaW5nTG9nZ2VyLnByb3RvdHlwZS5wcmludE91dHB1dCA9IGZ1bmN0aW9uKGxvZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKCFsb2dGdW5jdGlvbikgeyBsb2dGdW5jdGlvbiA9IHRoaXMubG9nRnVuY3Rpb247IH1cbiAgICB2YXIgdW5pcXVlSUQgPSB0aGlzLnVuaXF1ZUlEO1xuICAgIHRoaXMuYnVmZmVyLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBlbnRyeVswXS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB2YXIgYXJncyA9IGVudHJ5WzFdLnNsaWNlKCk7XG4gICAgICAgIHZhciBmb3JtYXRTdHJpbmcgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoZm9ybWF0U3RyaW5nICE9PSAodm9pZCAwKSAmJiBmb3JtYXRTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9ICclcyAtICVzIC0gJyArIGZvcm1hdFN0cmluZy50b1N0cmluZygpO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMSwgZm9ybWF0U3RyaW5nLCBkYXRlLCB1bmlxdWVJRCk7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbi5hcHBseShnbG9iYWwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbIm5vb3AiLCJleHBvcnRzIiwiZXh0ZW5kIiwiZGVzdCIsInNvdXJjZSIsInByb3AiLCJldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50IiwicmVxdWlyZSIsIkV2ZW50RW1pdHRlciIsImxpc3RlbmVyQ291bnQiLCJlbWl0dGVyIiwidHlwZSIsImxpc3RlbmVycyIsImxlbmd0aCIsImJ1ZmZlckFsbG9jVW5zYWZlIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJvbGRCdWZmZXJBbGxvY1Vuc2FmZSIsInNpemUiLCJidWZmZXJGcm9tU3RyaW5nIiwiZnJvbSIsIm9sZEJ1ZmZlckZyb21TdHJpbmciLCJzdHJpbmciLCJlbmNvZGluZyIsIkJ1ZmZlcmluZ0xvZ2dlciIsImNyZWF0ZUJ1ZmZlcmluZ0xvZ2dlciIsImlkZW50aWZpZXIiLCJ1bmlxdWVJRCIsImxvZ0Z1bmN0aW9uIiwiZW5hYmxlZCIsImxvZ2dlciIsImRlYnVnIiwibG9nIiwiYmluZCIsInByaW50T3V0cHV0IiwiYnVmZmVyIiwicHJvdG90eXBlIiwicHVzaCIsIkRhdGUiLCJBcnJheSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImNsZWFyIiwiZm9yRWFjaCIsImVudHJ5IiwiZGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwiYXJncyIsImZvcm1hdFN0cmluZyIsInRvU3RyaW5nIiwic3BsaWNlIiwiYXBwbHkiLCJnbG9iYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsa0hBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvdmVyc2lvbi5qcz8xNDIzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/lib/websocket.js":
/*!*************************************************!*\
  !*** ./node_modules/websocket/lib/websocket.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = {\n    \"server\": __webpack_require__(/*! ./WebSocketServer */ \"(rsc)/./node_modules/websocket/lib/WebSocketServer.js\"),\n    \"client\": __webpack_require__(/*! ./WebSocketClient */ \"(rsc)/./node_modules/websocket/lib/WebSocketClient.js\"),\n    \"router\": __webpack_require__(/*! ./WebSocketRouter */ \"(rsc)/./node_modules/websocket/lib/WebSocketRouter.js\"),\n    \"frame\": __webpack_require__(/*! ./WebSocketFrame */ \"(rsc)/./node_modules/websocket/lib/WebSocketFrame.js\"),\n    \"request\": __webpack_require__(/*! ./WebSocketRequest */ \"(rsc)/./node_modules/websocket/lib/WebSocketRequest.js\"),\n    \"connection\": __webpack_require__(/*! ./WebSocketConnection */ \"(rsc)/./node_modules/websocket/lib/WebSocketConnection.js\"),\n    \"w3cwebsocket\": __webpack_require__(/*! ./W3CWebSocket */ \"(rsc)/./node_modules/websocket/lib/W3CWebSocket.js\"),\n    \"deprecation\": __webpack_require__(/*! ./Deprecation */ \"(rsc)/./node_modules/websocket/lib/Deprecation.js\"),\n    \"version\": __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/websocket/lib/version.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUc7SUFDYixVQUFpQkMsbUJBQU9BLENBQUM7SUFDekIsVUFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLFVBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixTQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsV0FBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLGNBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixnQkFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLGVBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixXQUFpQkEsbUJBQU9BLENBQUM7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanM/ZTk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnc2VydmVyJyAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0U2VydmVyJyksXG4gICAgJ2NsaWVudCcgICAgICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldENsaWVudCcpLFxuICAgICdyb3V0ZXInICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRSb3V0ZXInKSxcbiAgICAnZnJhbWUnICAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0RnJhbWUnKSxcbiAgICAncmVxdWVzdCcgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0UmVxdWVzdCcpLFxuICAgICdjb25uZWN0aW9uJyAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyksXG4gICAgJ3czY3dlYnNvY2tldCcgOiByZXF1aXJlKCcuL1czQ1dlYlNvY2tldCcpLFxuICAgICdkZXByZWNhdGlvbicgIDogcmVxdWlyZSgnLi9EZXByZWNhdGlvbicpLFxuICAgICd2ZXJzaW9uJyAgICAgIDogcmVxdWlyZSgnLi92ZXJzaW9uJylcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/vendor/FastBufferList.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/vendor/FastBufferList.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar bufferAllocUnsafe = (__webpack_require__(/*! ../lib/utils */ \"(rsc)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    if (typeof opts == \"undefined\") opts = {};\n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    var head = {\n        next: null,\n        buffer: null\n    };\n    var last = {\n        next: null,\n        buffer: null\n    };\n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__(\"length\", function() {\n        return length;\n    });\n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function(buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        } else {\n            last.next = {\n                next: null,\n                buffer: buf\n            };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit(\"write\", buf);\n        return true;\n    };\n    self.end = function(buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function() {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function(fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        var b = {\n            buffer: firstBuf,\n            next: head.next\n        };\n        while(b && b.buffer){\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        return self;\n    };\n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function(start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (start < ix + buffer.length && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        return big;\n    };\n    self.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (sourceStart < ix + buffer.length && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        return big;\n    };\n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function(n) {\n        offset += n;\n        length -= n;\n        while(head.buffer && offset >= head.buffer.length){\n            offset -= head.buffer.length;\n            head = head.next ? head.next : {\n                buffer: null,\n                next: null\n            };\n        }\n        if (head.buffer === null) last = {\n            next: null,\n            buffer: null\n        };\n        self.emit(\"advance\", n);\n        return self;\n    };\n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function(n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== \"number\") {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = \"\";\n            self.forEach(function(buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    // The entire concatenated buffer as a string.\n    self.toString = function() {\n        return self.take(\"binary\");\n    };\n}\n(__webpack_require__(/*! util */ \"util\").inherits)(BufferList, EventEmitter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L3ZlbmRvci9GYXN0QnVmZmVyTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0U7QUFDeEUsMEVBQTBFO0FBQzFFLDRFQUE0RTtBQUU1RSxnQkFBZ0I7QUFDaEIsbUVBQW1FOztBQUNuRSxJQUFJQSxTQUFTQyxvREFBd0I7QUFDckMsSUFBSUMsZUFBZUQsMERBQThCO0FBQ2pELElBQUlFLG9CQUFvQkYsMEdBQXlDO0FBRWpFRyxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCRix5QkFBeUIsR0FBR0UsWUFBWSwwQkFBMEI7QUFFbEUsU0FBU0EsV0FBV0MsSUFBSTtJQUNwQixJQUFJLENBQUUsS0FBSSxZQUFZRCxVQUFTLEdBQUksT0FBTyxJQUFJQSxXQUFXQztJQUN6REwsYUFBYU0sSUFBSSxDQUFDLElBQUk7SUFDdEIsSUFBSUMsT0FBTyxJQUFJO0lBRWYsSUFBSSxPQUFPRixRQUFTLGFBQWFBLE9BQU8sQ0FBQztJQUV6Qyw2REFBNkQ7SUFDN0Qsd0NBQXdDO0lBQ3hDRSxLQUFLQyxRQUFRLEdBQUdILEtBQUtHLFFBQVE7SUFFN0IsSUFBSUMsT0FBTztRQUFFQyxNQUFPO1FBQU1DLFFBQVM7SUFBSztJQUN4QyxJQUFJQyxPQUFPO1FBQUVGLE1BQU87UUFBTUMsUUFBUztJQUFLO0lBRXhDLHFEQUFxRDtJQUNyRCxtQ0FBbUM7SUFDbkMsSUFBSUUsU0FBUztJQUNiTixLQUFLTyxnQkFBZ0IsQ0FBQyxVQUFVO1FBQzVCLE9BQU9EO0lBQ1g7SUFFQSxnRUFBZ0U7SUFDaEUsSUFBSUUsU0FBUztJQUViLCtEQUErRDtJQUMvRFIsS0FBS1MsS0FBSyxHQUFHLFNBQVVDLEdBQUc7UUFDdEIsSUFBSSxDQUFDUixLQUFLRSxNQUFNLEVBQUU7WUFDZEYsS0FBS0UsTUFBTSxHQUFHTTtZQUNkTCxPQUFPSDtRQUNYLE9BQ0s7WUFDREcsS0FBS0YsSUFBSSxHQUFHO2dCQUFFQSxNQUFPO2dCQUFNQyxRQUFTTTtZQUFJO1lBQ3hD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SUEsVUFBVTtZQUNWLElBQUkwQyxNQUFNO1lBQ1YzQyxLQUFLbUIsT0FBTyxDQUFDLFNBQVVmLE1BQU07Z0JBQ3pCLElBQUlxQyxLQUFLLEdBQUcsT0FBTztnQkFDbkJFLE9BQU92QyxPQUFPd0MsUUFBUSxDQUNsQjNDLFVBQVUsR0FBRzhCLEtBQUtFLEdBQUcsQ0FBQ1EsR0FBRXJDLE9BQU9FLE1BQU07Z0JBRXpDbUMsS0FBS3JDLE9BQU9FLE1BQU07WUFDdEI7WUFDQSxPQUFPcUM7UUFDWCxPQUFPO1lBQ0gsdURBQXVEO1lBQ3ZELE9BQU8zQyxLQUFLeUIsSUFBSSxDQUFDLEdBQUdnQjtRQUN4QjtJQUNKO0lBRUEsOENBQThDO0lBQzlDekMsS0FBSzRDLFFBQVEsR0FBRztRQUNaLE9BQU81QyxLQUFLMEMsSUFBSSxDQUFDO0lBQ3JCO0FBQ0o7QUFDQWxELGtEQUF3QixDQUFDSyxZQUFZSiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvdmVuZG9yL0Zhc3RCdWZmZXJMaXN0LmpzP2E2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svbm9kZS1idWZmZXJsaXN0XG4vLyBhbmQgbW9kaWZpZWQgdG8gYmUgYWJsZSB0byBjb3B5IGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmxpc3QgZGlyZWN0bHkgaW50b1xuLy8gYSBwcmUtZXhpc3RpbmcgZml4ZWQtc2l6ZSBidWZmZXIgd2l0aG91dCBhbiBhZGRpdGlvbmFsIG1lbW9yeSBhbGxvY2F0aW9uLlxuXG4vLyBidWZmZXJsaXN0LmpzXG4vLyBUcmVhdCBhIGxpbmtlZCBsaXN0IG9mIGJ1ZmZlcnMgYXMgYSBzaW5nbGUgdmFyaWFibGUtc2l6ZSBidWZmZXIuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpLmJ1ZmZlckFsbG9jVW5zYWZlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJMaXN0ID0gQnVmZmVyTGlzdDsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuZnVuY3Rpb24gQnVmZmVyTGlzdChvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKSByZXR1cm4gbmV3IEJ1ZmZlckxpc3Qob3B0cyk7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2Yob3B0cykgPT0gJ3VuZGVmaW5lZCcpIG9wdHMgPSB7fTtcbiAgICBcbiAgICAvLyBkZWZhdWx0IGVuY29kaW5nIHRvIHVzZSBmb3IgdGFrZSgpLiBMZWF2aW5nIGFzICd1bmRlZmluZWQnXG4gICAgLy8gbWFrZXMgdGFrZSgpIHJldHVybiBhIEJ1ZmZlciBpbnN0ZWFkLlxuICAgIHNlbGYuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nO1xuICAgIFxuICAgIHZhciBoZWFkID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIHZhciBsYXN0ID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIFxuICAgIC8vIGxlbmd0aCBjYW4gZ2V0IG5lZ2F0aXZlIHdoZW4gYWR2YW5jZWQgcGFzdCB0aGUgZW5kXG4gICAgLy8gYW5kIHRoaXMgaXMgdGhlIGRlc2lyZWQgYmVoYXZpb3JcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBzZWxmLl9fZGVmaW5lR2V0dGVyX18oJ2xlbmd0aCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBrZWVwIGFuIG9mZnNldCBvZiB0aGUgaGVhZCB0byBkZWNpZGUgd2hlbiB0byBoZWFkID0gaGVhZC5uZXh0XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgXG4gICAgLy8gV3JpdGUgdG8gdGhlIGJ1ZmZlcmxpc3QuIEVtaXRzICd3cml0ZScuIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgc2VsZi53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikge1xuICAgICAgICAgICAgaGVhZC5idWZmZXIgPSBidWY7XG4gICAgICAgICAgICBsYXN0ID0gaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QubmV4dCA9IHsgbmV4dCA6IG51bGwsIGJ1ZmZlciA6IGJ1ZiB9O1xuICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgc2VsZi5lbWl0KCd3cml0ZScsIGJ1Zik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5lbmQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkgc2VsZi53cml0ZShidWYpO1xuICAgIH07XG4gICAgXG4gICAgLy8gUHVzaCBidWZmZXJzIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0LiAoZGVwcmVjYXRlZClcbiAgICAvLyBSZXR1cm4gdGhpcyAoc2VsZikuXG4gICAgc2VsZi5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5mb3JFYWNoKHNlbGYud3JpdGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIEZvciBlYWNoIGJ1ZmZlciwgcGVyZm9ybSBzb21lIGFjdGlvbi5cbiAgICAvLyBJZiBmbidzIHJlc3VsdCBpcyBhIHRydWUgdmFsdWUsIGN1dCBvdXQgZWFybHkuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGhlYWQuYnVmZmVyLmxlbmd0aCAtIG9mZnNldCA8PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgICAgdmFyIGZpcnN0QnVmID0gaGVhZC5idWZmZXIuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBiID0geyBidWZmZXIgOiBmaXJzdEJ1ZiwgbmV4dCA6IGhlYWQubmV4dCB9O1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKGIgJiYgYi5idWZmZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gZm4oYi5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKHIpIGJyZWFrO1xuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW5nbGUgQnVmZmVyIG91dCBvZiBhbGwgdGhlIGNodW5rcyBvciBzb21lIHN1YnNldCBzcGVjaWZpZWQgYnlcbiAgICAvLyBzdGFydCBhbmQgb25lLXBhc3QgdGhlIGVuZCAobGlrZSBzbGljZSkgaW4gYnl0ZXMuXG4gICAgc2VsZi5qb2luID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBpZiAoc3RhcnQgPT0gdW5kZWZpbmVkKSBzdGFydCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT0gdW5kZWZpbmVkKSBlbmQgPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBiaWcgPSBidWZmZXJBbGxvY1Vuc2FmZShlbmQgLSBzdGFydCk7XG4gICAgICAgIHZhciBpeCA9IDA7XG4gICAgICAgIHNlbGYuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAoaXggKyBidWZmZXIubGVuZ3RoKSAmJiBpeCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IHBhcnRpYWxseSBjb250YWluZWQgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvcHkoXG4gICAgICAgICAgICAgICAgICAgIGJpZyxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgaXggLSBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIHN0YXJ0IC0gaXgpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBlbmQgLSBpeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpeCA+IGVuZCkgcmV0dXJuIHRydWU7IC8vIHN0b3AgcHJvY2Vzc2luZyBwYXN0IGVuZFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiaWc7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLmpvaW5JbnRvID0gZnVuY3Rpb24gKHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIG5ldyBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ID09IHVuZGVmaW5lZCkgc291cmNlU3RhcnQgPSAwO1xuICAgICAgICBpZiAoc291cmNlRW5kID09IHVuZGVmaW5lZCkgc291cmNlRW5kID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgYmlnID0gdGFyZ2V0QnVmZmVyO1xuICAgICAgICBpZiAoYmlnLmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgc291cmNlRW5kIC0gc291cmNlU3RhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBzcGFjZSBhdmFpbGFibGUgaW4gdGFyZ2V0IEJ1ZmZlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl4ID0gMDtcbiAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VTdGFydCA8IChpeCArIGJ1ZmZlci5sZW5ndGgpICYmIGl4IDwgc291cmNlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgcGFydGlhbGx5IGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShcbiAgICAgICAgICAgICAgICAgICAgYmlnLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0YXJnZXRTdGFydCwgdGFyZ2V0U3RhcnQgKyBpeCAtIHNvdXJjZVN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc291cmNlU3RhcnQgLSBpeCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJ1ZmZlci5sZW5ndGgsIHNvdXJjZUVuZCAtIGl4KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpeCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGl4ID4gc291cmNlRW5kKSByZXR1cm4gdHJ1ZTsgLy8gc3RvcCBwcm9jZXNzaW5nIHBhc3QgZW5kXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJpZztcbiAgICB9O1xuICAgIFxuICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBzdHJlYW0gYnkgbiBieXRlcy5cbiAgICAvLyBJZiBuIHRoZSBhZ2dyZWdhdGUgYWR2YW5jZSBvZmZzZXQgcGFzc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBsaXN0LFxuICAgIC8vIG9wZXJhdGlvbnMgc3VjaCBhcyAudGFrZSgpIHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZ3MgdW50aWwgZW5vdWdoIGRhdGEgaXNcbiAgICAvLyBwdXNoZWQuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmFkdmFuY2UgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgbGVuZ3RoIC09IG47XG4gICAgICAgIHdoaWxlIChoZWFkLmJ1ZmZlciAmJiBvZmZzZXQgPj0gaGVhZC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gaGVhZC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dFxuICAgICAgICAgICAgICAgID8gaGVhZC5uZXh0XG4gICAgICAgICAgICAgICAgOiB7IGJ1ZmZlciA6IG51bGwsIG5leHQgOiBudWxsIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZC5idWZmZXIgPT09IG51bGwpIGxhc3QgPSB7IG5leHQgOiBudWxsLCBidWZmZXIgOiBudWxsIH07XG4gICAgICAgIHNlbGYuZW1pdCgnYWR2YW5jZScsIG4pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRha2UgbiBieXRlcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVycy5cbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nLlxuICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHRoYW4gbiBieXRlcyBpbiBhbGwgdGhlIGJ1ZmZlcnMgb3IgbiBpcyB1bmRlZmluZWQsXG4gICAgLy8gcmV0dXJucyB0aGUgZW50aXJlIGNvbmNhdGVuYXRlZCBidWZmZXIgc3RyaW5nLlxuICAgIHNlbGYudGFrZSA9IGZ1bmN0aW9uIChuLCBlbmNvZGluZykge1xuICAgICAgICBpZiAobiA9PSB1bmRlZmluZWQpIG4gPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9IG47XG4gICAgICAgICAgICBuID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBoZWFkO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHNlbGYuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIGFjYyA9ICcnO1xuICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYnVmZmVyLnRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZywgMCwgTWF0aC5taW4obixidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbiAtPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gJ2VuY29kaW5nJyBpcyBzcGVjaWZpZWQsIHRoZW4gcmV0dXJuIGEgQnVmZmVyLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuam9pbigwLCBuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gVGhlIGVudGlyZSBjb25jYXRlbmF0ZWQgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICAgIHNlbGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRha2UoJ2JpbmFyeScpO1xuICAgIH07XG59XG5yZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRXZlbnRFbWl0dGVyKTtcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyTGlzdCIsIm9wdHMiLCJjYWxsIiwic2VsZiIsImVuY29kaW5nIiwiaGVhZCIsIm5leHQiLCJidWZmZXIiLCJsYXN0IiwibGVuZ3RoIiwiX19kZWZpbmVHZXR0ZXJfXyIsIm9mZnNldCIsIndyaXRlIiwiYnVmIiwiZW1pdCIsImVuZCIsImlzQnVmZmVyIiwicHVzaCIsImFyZ3MiLCJjb25jYXQiLCJhcHBseSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJmbiIsImZpcnN0QnVmIiwic2xpY2UiLCJiIiwiciIsImpvaW4iLCJzdGFydCIsInVuZGVmaW5lZCIsImJpZyIsIml4IiwiY29weSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJqb2luSW50byIsInRhcmdldEJ1ZmZlciIsInRhcmdldFN0YXJ0Iiwic291cmNlU3RhcnQiLCJzb3VyY2VFbmQiLCJFcnJvciIsImFkdmFuY2UiLCJuIiwidGFrZSIsImFjYyIsInRvU3RyaW5nIiwiaW5oZXJpdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/websocket/vendor/FastBufferList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

};
;